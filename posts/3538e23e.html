<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>My acm-icpc template | 浮生若梦</title><meta name="author" content="Meta Xiao"><meta name="copyright" content="Meta Xiao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="前言由于本人实例还不能到cf青名，用不上jiangly哥哥的代码，暂时自己结合网上的代码和自己的理解写一个模板，日后再更新。  使用 pandoc My-acm-icpc-template.md -o My-acm-icpc-template.docx —toc —highlight-style&#x3D;tango导出为word  头、编译、debug头12345678910111213141516171">
<meta property="og:type" content="article">
<meta property="og:title" content="My acm-icpc template">
<meta property="og:url" content="https://www.teslongxiao.cn/posts/3538e23e.html">
<meta property="og:site_name" content="浮生若梦">
<meta property="og:description" content="前言由于本人实例还不能到cf青名，用不上jiangly哥哥的代码，暂时自己结合网上的代码和自己的理解写一个模板，日后再更新。  使用 pandoc My-acm-icpc-template.md -o My-acm-icpc-template.docx —toc —highlight-style&#x3D;tango导出为word  头、编译、debug头12345678910111213141516171">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/icpc-logo.png">
<meta property="article:published_time" content="2025-09-09T04:43:54.000Z">
<meta property="article:modified_time" content="2026-01-18T17:08:36.723Z">
<meta property="article:author" content="Meta Xiao">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/icpc-logo.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "My acm-icpc template",
  "url": "https://www.teslongxiao.cn/posts/3538e23e.html",
  "image": "https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/icpc-logo.png",
  "datePublished": "2025-09-09T04:43:54.000Z",
  "dateModified": "2026-01-18T17:08:36.723Z",
  "author": [
    {
      "@type": "Person",
      "name": "Meta Xiao",
      "url": "https://www.teslongxiao.cn/"
    }
  ]
}</script><link rel="shortcut icon" href="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/image.png"><link rel="canonical" href="https://www.teslongxiao.cn/posts/3538e23e.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="Qi_9CrV7lldy8VD7RIVN3Nb62FP7EmhAITFqplx0mzo"/><meta name="baidu-site-verification" content="codeva-nF4CVmePFG"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f6e1da')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: Meta Xiao","link":"链接: ","source":"来源: 浮生若梦","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-center"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'My acm-icpc template',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">

<link rel="stylesheet" href="/css/recommend.css?v=1.1.2.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/css/flash.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-image: url(https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/subway_girl.gif);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/1737896078867.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fa-tools"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-user"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/talks/"><i class="fa-fw fas fa-coffee"></i><span> 动态</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/icpc-logo.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/bar-logo.png" alt="Logo"><span class="site-name">浮生若梦</span></a><a class="nav-page-title" href="/"><span class="site-name">My acm-icpc template</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fa-tools"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><span class="site-page group hide"><i class="fa-fw fas fa-user"></i><span> 我的</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/talks/"><i class="fa-fw fas fa-coffee"></i><span> 动态</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">My acm-icpc template</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-09T04:43:54.000Z" title="发表于 2025-09-09 12:43:54">2025-09-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-18T17:08:36.723Z" title="更新于 2026-01-19 01:08:36">2026-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/%E6%A8%A1%E6%9D%BF/">模板</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><div class="top-img gist" style="background-image: url(https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/icpc-logo.png)"></div><article class="container post-content" id="article-container"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于本人实例还不能到cf青名，用不上jiangly哥哥的代码，暂时自己结合网上的代码和自己的理解写一个模板，日后再更新。</p>
<blockquote>
<p>使用 pandoc My-acm-icpc-template.md -o My-acm-icpc-template.docx —toc —highlight-style=tango导出为word</p>
</blockquote>
<h1 id="头、编译、debug"><a href="#头、编译、debug" class="headerlink" title="头、编译、debug"></a>头、编译、debug</h1><h2 id="头"><a href="#头" class="headerlink" title="头"></a>头</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O2 O3 优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;O2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;O3&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 如果是clang或者gcc 则使用以下头文件</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt;</span></span><br><span class="line"><span class="comment">#include &lt;set&gt;</span></span><br><span class="line"><span class="comment">#include &lt;map&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include &lt;functional&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unordered_map&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unordered_set&gt;</span></span><br><span class="line"><span class="comment">#include &lt;climits&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常用宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pnt(x) cout&lt;&lt;#x&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;(x)&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pnt2(x, y) cout&lt;&lt;#x&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;(x)&lt;&lt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;#y&lt;&lt;<span class="string">&#x27;=&#x27;</span>&lt;&lt;(y)&lt;&lt;endl </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 快速输出stl的线性容器</span></span><br><span class="line"><span class="comment">template &lt;typename T1, typename T2&gt;</span></span><br><span class="line"><span class="comment">ostream &amp;operator&lt;&lt;(ostream &amp;o, const pair&lt;T1, T2&gt; &amp;p)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    return o &lt;&lt; &quot;&lt;&quot; &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; &quot;&gt;&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">template &lt;typename T&gt;</span></span><br><span class="line"><span class="comment">typename enable_if&lt;</span></span><br><span class="line"><span class="comment">    !is_same&lt;T, string&gt;::value &amp;&amp;</span></span><br><span class="line"><span class="comment">    is_same&lt;decltype(begin(declval&lt;T&gt;())), decltype(end(declval&lt;T&gt;()))&gt;::value,</span></span><br><span class="line"><span class="comment">    ostream&amp;</span></span><br><span class="line"><span class="comment">&gt;::type</span></span><br><span class="line"><span class="comment">operator&lt;&lt;(ostream &amp;o, const T &amp;v)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    o &lt;&lt; &quot;&#123;&quot;;</span></span><br><span class="line"><span class="comment">    for (auto it = begin(v); it != end(v); ++it)</span></span><br><span class="line"><span class="comment">        o &lt;&lt; (it == begin(v) ? &quot;&quot; : &quot; ,&quot;) &lt;&lt; *it;</span></span><br><span class="line"><span class="comment">    return o &lt;&lt; &quot;&#125;&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 关闭同步流 加快IO</span></span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><ul>
<li>命令运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++17 -O2 -Wall -Wextra -o XXX XXX.cpp</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./XXX &lt; X.input &gt; X.output</span><br></pre></td></tr></table></figure>
<p>这里使用脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"><span class="comment">#usage: ./run &lt;filename&gt;</span></span><br><span class="line"><span class="comment">#example: ./run a (will compile a.cpp, run with a.input, output to a.output, compare with a.ans)</span></span><br><span class="line"></span><br><span class="line">g++ -std=c++17 -O2 -o <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="string">&quot;<span class="variable">$1</span>.cpp&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line">./<span class="string">&quot;<span class="variable">$1</span>&quot;</span> &lt; <span class="string">&quot;<span class="variable">$1</span>.input&quot;</span> &gt; <span class="string">&quot;<span class="variable">$1</span>.output&quot;</span></span><br><span class="line">diff -q <span class="string">&quot;<span class="variable">$1</span>.output&quot;</span> <span class="string">&quot;<span class="variable">$1</span>.ans&quot;</span> &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;AC&quot;</span> || <span class="built_in">echo</span> <span class="string">&quot;WA&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="一些常量"><a href="#一些常量" class="headerlink" title="一些常量"></a>一些常量</h1><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">范围</th>
<th style="text-align:center">常量名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">$[-2^{31}, 2^{31}-1]$ 即 $[-2147483648, 2147483647]$</td>
<td style="text-align:center"><code>INT_MAX</code> <code>INT_MIN</code> <code>UINT_MAX</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long long</code></td>
<td style="text-align:center">$[-2^{63}, 2^{63}-1]$ 即 $[-9223372036854775808, 9223372036854775807]$</td>
<td style="text-align:center"><code>LLONG_MAX</code> <code>LLONG_MIN</code> <code>ULLONG_MAX</code></td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">$[-3.4 \times 10^{38}, 3.4 \times 10^{38}]$</td>
<td style="text-align:center"><code>FLT_MAX</code> <code>FLT_MIN</code> <code>DBL_MAX</code> <code>DBL_MIN</code></td>
</tr>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">$[0, 255]$</td>
<td style="text-align:center"><code>CHAR_MAX</code> <code>CHAR_MIN</code> <code>UCHAR_MAX</code></td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">$[-1.7 \times 10^{-308}, 1.7 \times 10^{308}]$</td>
<td style="text-align:center"><code>DBL_MAX</code> <code>DBL_MIN</code></td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center">$[-1.1 \times 10^{-4932}, 1.1 \times 10^{4932}]$</td>
<td style="text-align:center"><code>LDBL_MAX</code> <code>LDBL_MIN</code></td>
</tr>
</tbody>
</table>
</div>
<h1 id="时间复杂度预估"><a href="#时间复杂度预估" class="headerlink" title="时间复杂度预估"></a>时间复杂度预估</h1><blockquote>
<p>这里时间限制为1s</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">复杂度</th>
<th style="text-align:center">勉强能过的数据规模</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$O(1)$</td>
<td style="text-align:center">任意（常数）</td>
</tr>
<tr>
<td style="text-align:center">$O(\log n)$</td>
<td style="text-align:center">$n\le 10^{18}$ 甚至更大</td>
</tr>
<tr>
<td style="text-align:center">$O(\sqrt n)$</td>
<td style="text-align:center">$n\le 10^{12}$</td>
</tr>
<tr>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$n\le 10^{6}$</td>
</tr>
<tr>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$n\le 10^{5}$</td>
</tr>
<tr>
<td style="text-align:center">$O(n^2)$</td>
<td style="text-align:center">$n \le 3\times10^{4}$（上限取决于常数）</td>
</tr>
<tr>
<td style="text-align:center">$O(n^3)$</td>
<td style="text-align:center">$n \le 500$</td>
</tr>
<tr>
<td style="text-align:center">$O(2^n)$</td>
<td style="text-align:center">$n \le 20$</td>
</tr>
<tr>
<td style="text-align:center">$O(n!)$</td>
<td style="text-align:center">$n \le 10$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="数据结构模板"><a href="#数据结构模板" class="headerlink" title="数据结构模板"></a>数据结构模板</h1><h2 id="大数高精度模拟"><a href="#大数高精度模拟" class="headerlink" title="大数高精度模拟"></a>大数高精度模拟</h2><p>处理大数 $10^{1000}$ 级别的加减乘除</p>
<h3 id="手写结构"><a href="#手写结构" class="headerlink" title="手写结构"></a>手写结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BigInte</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="type">int</span> sign;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInte</span>(ll num=<span class="number">0</span>)&#123;*<span class="keyword">this</span>=num;&#125;</span><br><span class="line">    <span class="built_in">BigInte</span>(<span class="type">const</span> string s)&#123;*<span class="keyword">this</span>=s;&#125;</span><br><span class="line"></span><br><span class="line">    BigInte&amp; <span class="keyword">operator</span>=(ll num)</span><br><span class="line">    &#123;</span><br><span class="line">        d.<span class="built_in">clear</span>(); sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;<span class="number">0</span>) sign=<span class="number">-1</span>, num=-num;</span><br><span class="line">        <span class="keyword">if</span>(num==<span class="number">0</span>) d.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">        &#123;</span><br><span class="line">            d.<span class="built_in">push_back</span>(num%<span class="number">10</span>);</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInte&amp; <span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        d.<span class="built_in">clear</span>(); sign=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;-&#x27;</span>) sign=<span class="number">-1</span>, start=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=start; i--)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[i])) d.<span class="built_in">push_back</span>(s[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="built_in">trim</span>();  <span class="comment">// 去除前导0</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trim</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!d.<span class="built_in">empty</span>() &amp;&amp; !d.<span class="built_in">back</span>()) d.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; d[<span class="number">0</span>]==<span class="number">0</span>) sign=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">str</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string s=(sign==<span class="number">-1</span>? <span class="string">&quot;-&quot;</span>:<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)d.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)s+=<span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span>+d[i]);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">absLess</span><span class="params">(<span class="type">const</span> BigInte &amp;b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(d.<span class="built_in">size</span>()!=b.d.<span class="built_in">size</span>()) <span class="keyword">return</span> d.<span class="built_in">size</span>()&lt;b.d.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)d.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>(d[i]!=b.d[i]) <span class="keyword">return</span> d[i]&lt;b.d[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> BigInte &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sign!=b.sign) <span class="keyword">return</span> sign&lt;b.sign;</span><br><span class="line">        <span class="keyword">if</span>(sign==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">absLess</span>(b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> b.<span class="built_in">absLess</span>(*<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BigInte &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sign==b.sign &amp;&amp; d==b.d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInte <span class="keyword">operator</span>+(<span class="type">const</span> BigInte &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sign==b.sign)</span><br><span class="line">        &#123;</span><br><span class="line">            BigInte c;</span><br><span class="line">            c.sign=sign;</span><br><span class="line">            c.d.<span class="built_in">resize</span>(<span class="built_in">max</span>(d.<span class="built_in">size</span>(), b.d.<span class="built_in">size</span>())<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;c.d.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> x=carry;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;d.<span class="built_in">size</span>()) x+=d[i];</span><br><span class="line">                <span class="keyword">if</span>(i&lt;b.d.<span class="built_in">size</span>()) x+=b.d[i];</span><br><span class="line">                c.d[i]=x%<span class="number">10</span>;</span><br><span class="line">                carry=x/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c.<span class="built_in">trim</span>();</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-(-b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInte <span class="keyword">operator</span>-() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        BigInte c=*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(d.<span class="built_in">size</span>()==<span class="number">1</span> &amp;&amp; d[<span class="number">0</span>]==<span class="number">0</span>)) c.sign=-c.sign;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInte <span class="keyword">operator</span>-(<span class="type">const</span> BigInte &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sign!=b.sign) <span class="keyword">return</span> *<span class="keyword">this</span>+(-b);</span><br><span class="line">        <span class="keyword">if</span>((sign==<span class="number">1</span> &amp;&amp; *<span class="keyword">this</span>&lt;b) || (sign==<span class="number">-1</span> &amp;&amp; b&lt;*<span class="keyword">this</span>)) <span class="keyword">return</span> -(b-*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        BigInte c;</span><br><span class="line">        c.sign=sign;</span><br><span class="line">        c.d.<span class="built_in">resize</span>(d.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> borrow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;d.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=d[i]-borrow;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;b.d.<span class="built_in">size</span>()) x-=b.d[i];</span><br><span class="line">            <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=<span class="number">10</span>, borrow=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> borrow=<span class="number">0</span>;</span><br><span class="line">            c.d[i]=x;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInte <span class="keyword">operator</span>*(<span class="type">const</span> BigInte &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        BigInte c;</span><br><span class="line">        c.sign=sign*b.sign;</span><br><span class="line">        c.d.<span class="built_in">assign</span>(d.<span class="built_in">size</span>()+b.d.<span class="built_in">size</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> i=<span class="number">0</span>; i&lt;d.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">size_t</span> j=<span class="number">0</span>; j&lt;b.d.<span class="built_in">size</span>() || carry; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> cur=c.d[i+j]+(<span class="type">long</span> <span class="type">long</span>)d[i]*(j&lt;b.d.<span class="built_in">size</span>()? b.d[j]:<span class="number">0</span>)+carry;</span><br><span class="line">                c.d[i+j]=cur%<span class="number">10</span>;</span><br><span class="line">                carry=cur/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        c.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下取整</span></span><br><span class="line">    BigInte <span class="keyword">operator</span>/(<span class="type">const</span> BigInte &amp;b) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        BigInte a=*<span class="keyword">this</span>, div=b;</span><br><span class="line">        a.sign=div.sign=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">absLess</span>(div)) <span class="keyword">return</span> <span class="built_in">BigInte</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        BigInte cur=<span class="number">0</span>, res;</span><br><span class="line">        res.d.<span class="built_in">resize</span>(d.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)d.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            cur.d.<span class="built_in">insert</span>(cur.d.<span class="built_in">begin</span>(),d[i]);</span><br><span class="line">            cur.<span class="built_in">trim</span>();</span><br><span class="line">            <span class="type">int</span> x=<span class="number">0</span>, l=<span class="number">0</span>, r=<span class="number">9</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">                BigInte t=div*m;</span><br><span class="line">                <span class="keyword">if</span>(!cur.<span class="built_in">absLess</span>(t)) x=m, l=m<span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">else</span> r=m<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.d[i]=x;</span><br><span class="line">            cur=cur-div*x;</span><br><span class="line">        &#125;</span><br><span class="line">        res.sign=sign*b.sign;</span><br><span class="line">        res.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="comment">BigInte a(&quot;1234987329857423985794783259&quot;);</span></span><br><span class="line"><span class="comment">BigInte b(&quot;124098321759817239843279812374&quot;);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; (a+b).str() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; (a*b).str() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="语言自带"><a href="#语言自带" class="headerlink" title="语言自带"></a>语言自带</h3><p>但是这里不推荐使用大数模拟来写，<code>cpp</code>的大数有<code>__int128</code>， <code>python</code>的<code>double</code>也支持</p>
<ul>
<li><code>__int128</code> 的使用（范围：$[-2^{127}, 2^{127}-1]$）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, i128&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    string s; is&gt;&gt;s;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c: s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) &#123;flag=<span class="number">-1</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        x=x*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    x*=flag;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, i128 x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) &#123;os&lt;&lt;<span class="string">&#x27;-&#x27;</span>; x=-x;&#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>) os&lt;&lt;(x/<span class="number">10</span>);</span><br><span class="line">    os&lt;&lt;(<span class="type">int</span>)(x%<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加减乘除模</span></span><br><span class="line"><span class="function">i128 <span class="title">add</span><span class="params">(i128 a, i128 b)</span></span>&#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line"><span class="function">i128 <span class="title">sub</span><span class="params">(i128 a, i128 b)</span></span>&#123;<span class="keyword">return</span> a-b;&#125;</span><br><span class="line"><span class="function">i128 <span class="title">mul</span><span class="params">(i128 a, i128 b)</span></span>&#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line"><span class="function">i128 <span class="title">div</span><span class="params">(i128 a, i128 b)</span></span>&#123;<span class="keyword">return</span> a/b;&#125; <span class="comment">// 向0取整</span></span><br><span class="line"><span class="function">i128 <span class="title">mod</span><span class="params">(i128 a, i128 b)</span></span>&#123;<span class="keyword">return</span> a%b;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下取整除法</span></span><br><span class="line"><span class="function">i128 <span class="title">floorDiv</span><span class="params">(i128 a, i128 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b - (a%b!=<span class="number">0</span> &amp;&amp; (a^b)&lt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开方（整数部分）</span></span><br><span class="line"><span class="function">i128 <span class="title">sqrtI128</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    i128 l=<span class="number">1</span>, r=<span class="number">1e18</span>, ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        i128 m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&lt;=x/m) ans=m, l=m<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">else</span> r=m<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">i128 <span class="title">qpow</span><span class="params">(i128 a, i128 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i128 res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带模快速幂</span></span><br><span class="line"><span class="function">i128 <span class="title">qpowm</span><span class="params">(i128 a, i128 b, i128 mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i128 res=<span class="number">1</span>%mod;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCD</span></span><br><span class="line"><span class="function">i128 <span class="title">gcd</span><span class="params">(i128 a, i128 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCM</span></span><br><span class="line"><span class="function">i128 <span class="title">lcm</span><span class="params">(i128 a, i128 b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/<span class="built_in">gcd</span>(a,b)*b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// log2（整数部分）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">log2I128</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// log10（整数部分）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">log10I128</span><span class="params">(i128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x&gt;=<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x/=<span class="number">10</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用例子：</span></span><br><span class="line"><span class="comment">i128 a, b;</span></span><br><span class="line"><span class="comment">cin&gt;&gt;a&gt;&gt;b;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;add(a,b)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;sqrtI128(a)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;gcd(a,b)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;log2I128(a)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n,cnt;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fa, sz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> _n)</span><br><span class="line">    &#123;</span><br><span class="line">        n=_n;</span><br><span class="line">        cnt=_n; <span class="comment">// 统计集合个数</span></span><br><span class="line">        fa.<span class="built_in">resize</span>(n);</span><br><span class="line">        sz.<span class="built_in">resize</span>(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x]!=x) fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ra=<span class="built_in">find</span>(x), rb=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(ra!=rb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sz[ra]&lt;sz[rb]) <span class="built_in">swap</span>(ra, rb);</span><br><span class="line">            fa[rb]=ra;</span><br><span class="line">            sz[ra]+=sz[rb];</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p>需要频繁子串比较 / 多次查询：用<strong>哈希</strong>更方便，尤其是在线性区间查询时几乎必选。</p>
<h3 id="双值hash"><a href="#双值hash" class="headerlink" title="双值hash"></a>双值hash</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ull base=<span class="number">131</span>;</span><br><span class="line">ull mod1=<span class="number">212370440130137957</span>, mod2=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">hash1</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">  ull ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)ans=(ans*base+(ull)s[i])%mod1;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ull <span class="title">hash2</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">  ull ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) ans=(ans*base+(ull)s[i])%mod2;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> string s, <span class="type">const</span> string t)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> f1=(<span class="built_in">hash1</span>(s)!=<span class="built_in">hash1</span>(t));</span><br><span class="line">  <span class="type">bool</span> f2=(<span class="built_in">hash2</span>(s)!=<span class="built_in">hash2</span>(t));</span><br><span class="line">  <span class="keyword">return</span> f1||f2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子串hash匹配"><a href="#子串hash匹配" class="headerlink" title="子串hash匹配"></a>子串hash匹配</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StringHash</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> ull = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> ull base = <span class="number">131</span>;</span><br><span class="line">    vector&lt;ull&gt; h, p;             <span class="comment">// h 前缀哈希, p 幂次表</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">StringHash</span>(<span class="type">const</span> string &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        h.<span class="built_in">assign</span>(n<span class="number">+1</span>, <span class="number">0</span>);</span><br><span class="line">        p.<span class="built_in">assign</span>(n<span class="number">+1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            h[i]=h[i<span class="number">-1</span>]*base+(s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>);</span><br><span class="line">            p[i]=p[i<span class="number">-1</span>]*base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询子串 [l,r] 的哈希 (1-indexed)</span></span><br><span class="line">    <span class="function">ull <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l<span class="number">+1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用例子，判断字字串符串是否相等 ：</p>
<ol>
<li>这里先预处理字符串的hash前缀</li>
</ol>
<script type="math/tex; mode=display">
H[i+1]=(H[i]\cdot base+s[i]) \ (\mathbf{mod} \ M)</script><ol>
<li>然后再计算子串<code>s[l,l+1,,,r-1,r]</code>的hash，并对比</li>
</ol>
<script type="math/tex; mode=display">
hash(l,r)=(H[r]-H[l-1]\cdot base^{r-l+1})\ (\mathbf{mod} \ M)</script><h2 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryHeap</span> <span class="comment">// 大根堆</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="type">int</span> i=heap.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;<span class="number">1</span>&amp;&amp;heap[i]&gt;heap[i/<span class="number">2</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[i],heap[i/<span class="number">2</span>]);</span><br><span class="line">            i/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=heap.<span class="built_in">size</span>();</span><br><span class="line">        heap[<span class="number">1</span>]=heap[n<span class="number">-1</span>];</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> lgst=i;</span><br><span class="line">            <span class="type">int</span> l=i*<span class="number">2</span>, r=i*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">if</span>(l&lt;n &amp;&amp; heap[l]&gt;heap[lgst]) lgst=l;</span><br><span class="line">            <span class="keyword">if</span>(r&lt;n &amp;&amp; heap[r]&gt;heap[lgst]) lgst=r;</span><br><span class="line">            <span class="keyword">if</span>(lgst==i) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(heap[i],heap[lgst]);</span><br><span class="line">            i=lgst;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heap[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.<span class="built_in">size</span>()/<span class="number">2</span>; i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=i; </span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> lgst=j;</span><br><span class="line">                <span class="type">int</span> l=j*<span class="number">2</span>, r=j*<span class="number">2</span><span class="number">+1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l&lt;arr.<span class="built_in">size</span>() &amp;&amp; arr[l]&gt;arr[lgst]) lgst=l;</span><br><span class="line">                <span class="keyword">if</span>(r&lt;arr.<span class="built_in">size</span>() &amp;&amp; arr[r]&gt;arr[lgst]) lgst=r;</span><br><span class="line">                <span class="keyword">if</span>(lgst==j) <span class="keyword">break</span>;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j],arr[lgst]);</span><br><span class="line">                j=lgst;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用法：</span></span><br><span class="line"><span class="comment">BinaryHeap heap;</span></span><br><span class="line"><span class="comment">heap.push(1);</span></span><br><span class="line"><span class="comment">heap.push(2);</span></span><br><span class="line"><span class="comment">heap.push(3);</span></span><br><span class="line"><span class="comment">heap.pop();</span></span><br><span class="line"><span class="comment">cout &lt;&lt; heap.top() &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; arr=&#123;3,212,33,44,15&#125;;</span></span><br><span class="line"><span class="comment">BinaryHeap heapp;</span></span><br><span class="line"><span class="comment">heapp.buildHeap(arr);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>支持单点更新<code>add(x, val)</code>, 前缀查询<code>sum(x)</code>, 区间查询<code>rangeSum(l, r)</code></p>
<ul>
<li>一维树状数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200005</span>;</span><br><span class="line">ll bit[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x&lt;=n; x+=<span class="built_in">lowbit</span>(x)) bit[x]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x&gt;<span class="number">0</span>; x-=<span class="built_in">lowbit</span>(x)) s+=bit[x];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [l,r] 区间</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(r)-<span class="built_in">sum</span>(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="built_in">add</span>(i,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用法：</span></span><br><span class="line"><span class="comment">vector&lt;int&gt; a=&#123;0,1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">n=a.size();</span></span><br><span class="line"><span class="comment">build(a);</span></span><br><span class="line"><span class="comment">add(pos, delta);</span></span><br><span class="line"><span class="comment">cout &lt;&lt; rangeSum(l, r) &lt;&lt; &quot;\n&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>二维树状数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2005</span>;</span><br><span class="line">ll bit2[N][N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=n; i+=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y; j&lt;=m; j+=<span class="built_in">lowbit</span>(j))</span><br><span class="line">            bit2[i][j]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x; i&gt;<span class="number">0</span>; i-=<span class="built_in">lowbit</span>(i))</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y; j&gt;<span class="number">0</span>; j-=<span class="built_in">lowbit</span>(j))</span><br><span class="line">            s+=bit2[i][j];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [(x1,y1),(x2,y2)] 矩形</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(x2,y2)-<span class="built_in">sum</span>(x1<span class="number">-1</span>,y2)-<span class="built_in">sum</span>(x2,y1<span class="number">-1</span>)+<span class="built_in">sum</span>(x1<span class="number">-1</span>,y1<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>支持单点加/区间加，区间和， 前缀第k小的一维树状数组</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200005</span>;</span><br><span class="line">ll bit1[N], bit2[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x&amp;(-x);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x&lt;=n; x+=<span class="built_in">lowbit</span>(x)) bit1[x]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x&gt;<span class="number">0</span>; x-=<span class="built_in">lowbit</span>(x)) s+=bit1[x];</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未加的区间和</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rangeSum1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum1</span>(r)-<span class="built_in">sum1</span>(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间加--单点查</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rangeAdd1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add1</span>(l,v);</span><br><span class="line">    <span class="built_in">add1</span>(r<span class="number">+1</span>,-v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pointQuery</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum1</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间加--区间和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add2</span><span class="params">(ll *bit, <span class="type">int</span> x, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x&lt;=n; x+=<span class="built_in">lowbit</span>(x)) bit[x]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">rangeAdd2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add2</span>(bit1,l,v);</span><br><span class="line">    <span class="built_in">add2</span>(bit1,r<span class="number">+1</span>,-v);</span><br><span class="line">    <span class="built_in">add2</span>(bit2,l,v*(l<span class="number">-1</span>));</span><br><span class="line">    <span class="built_in">add2</span>(bit2,r<span class="number">+1</span>,-v*r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">sum2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll s1=<span class="number">0</span>, s2=<span class="number">0</span>, t=x;</span><br><span class="line">    <span class="keyword">for</span>(; x&gt;<span class="number">0</span>; x-=<span class="built_in">lowbit</span>(x))</span><br><span class="line">    &#123;</span><br><span class="line">        s1+=bit1[x];</span><br><span class="line">        s2+=bit2[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1*t-s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rangeSum2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum2</span>(r)-<span class="built_in">sum2</span>(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用这个kth时</span></span><br><span class="line"><span class="comment">应该声明使用bit来表示频率数组，如</span></span><br><span class="line"><span class="comment">memset(bit,0,sizeof(bit));</span></span><br><span class="line"><span class="comment">n=5;</span></span><br><span class="line"><span class="comment">add(1,2); // 2个1</span></span><br><span class="line"><span class="comment">add(2,3); // 3个2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>&lt;&lt;<span class="number">20</span>; i; i&gt;&gt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pos+i&lt;=n &amp;&amp; bit1[pos+i]&lt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            k-=bit1[pos+i];</span><br><span class="line">            pos+=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ST表"><a href="#ST表" class="headerlink" title="ST表"></a>ST表</h2><p>支持 $O(n\log n)$ 预处理，$O(1)$ 查询区间最值（不支持修改）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG=<span class="number">17</span>;</span><br><span class="line"><span class="type">int</span> st[N][LOG], lg[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) st[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;LOG; j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n; i++)</span><br><span class="line">            st[i][j]=<span class="built_in">max</span>(st[i][j<span class="number">-1</span>], st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">    </span><br><span class="line">    lg[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) lg[i]=lg[i/<span class="number">2</span>]<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k=lg[r-l<span class="number">+1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(st[l][k], st[r-(<span class="number">1</span>&lt;&lt;k)<span class="number">+1</span>][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>支持 $O(\log n)$ 单点/区间修改和查询</p>
<h3 id="基础区间和-懒标记"><a href="#基础区间和-懒标记" class="headerlink" title="基础区间和+懒标记"></a>基础区间和+懒标记</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line">ll tree[N&lt;&lt;<span class="number">2</span>], lazy[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[rt]=tree[rt&lt;&lt;<span class="number">1</span>]+tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> ln, <span class="type">int</span> rn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt]*ln;</span><br><span class="line">        tree[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt]*rn;</span><br><span class="line">        lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt, <span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt]=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, m, rt&lt;&lt;<span class="number">1</span>, a);</span><br><span class="line">    <span class="built_in">build</span>(m<span class="number">+1</span>, r, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, a);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, ll val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[rt]+=val*(r-l<span class="number">+1</span>);</span><br><span class="line">        lazy[rt]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt, m-l<span class="number">+1</span>, r-m);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m) <span class="built_in">update</span>(L, R, val, l, m, rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m) <span class="built_in">update</span>(L, R, val, m<span class="number">+1</span>, r, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> tree[rt];</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt, m-l<span class="number">+1</span>, r-m);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m) res+=<span class="built_in">query</span>(L, R, l, m, rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m) res+=<span class="built_in">query</span>(L, R, m<span class="number">+1</span>, r, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">int a[N];</span></span><br><span class="line"><span class="comment">build(1, n, 1, a);</span></span><br><span class="line"><span class="comment">update(l, r, val, 1, n, 1); // 区间[l,r]加val</span></span><br><span class="line"><span class="comment">ll ans=query(l, r, 1, n, 1); // 查询区间[l,r]和</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="动态开点线段树"><a href="#动态开点线段树" class="headerlink" title="动态开点线段树"></a>动态开点线段树</h3><p>适用于值域很大但修改/查询次数少的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e7</span>; <span class="comment">// 节点数上限</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ls, rs;</span><br><span class="line">    ll val, lazy;</span><br><span class="line">&#125;tr[N];</span><br><span class="line"><span class="type">int</span> root, idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tr[rt].val=tr[tr[rt].ls].val+tr[tr[rt].rs].val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> ln, <span class="type">int</span> rn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].ls) tr[rt].ls=++idx;</span><br><span class="line">    <span class="keyword">if</span>(!tr[rt].rs) tr[rt].rs=++idx;</span><br><span class="line">    <span class="keyword">if</span>(tr[rt].lazy)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[tr[rt].ls].val+=tr[rt].lazy*ln;</span><br><span class="line">        tr[tr[rt].rs].val+=tr[rt].lazy*rn;</span><br><span class="line">        tr[tr[rt].ls].lazy+=tr[rt].lazy;</span><br><span class="line">        tr[tr[rt].rs].lazy+=tr[rt].lazy;</span><br><span class="line">        tr[rt].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, ll val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> &amp;rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) rt=++idx;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R)</span><br><span class="line">    &#123;</span><br><span class="line">        tr[rt].val+=val*(r-l<span class="number">+1</span>);</span><br><span class="line">        tr[rt].lazy+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt, m-l<span class="number">+1</span>, r-m);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m) <span class="built_in">update</span>(L, R, val, l, m, tr[rt].ls);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m) <span class="built_in">update</span>(L, R, val, m<span class="number">+1</span>, r, tr[rt].rs);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rt) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> tr[rt].val;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt, m-l<span class="number">+1</span>, r-m);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m) res+=<span class="built_in">query</span>(L, R, l, m, tr[rt].ls);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m) res+=<span class="built_in">query</span>(L, R, m<span class="number">+1</span>, r, tr[rt].rs);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>维护一个单调递增或递减的栈，用于求每个元素<strong>左边/右边第一个比它大/小的元素</strong>。</p>
<p>从左到右遍历，栈中维护单调性。若当前元素破坏单调性，则弹出栈顶直到满足条件。常见应用：最大矩形面积、接雨水等。</p>
<h3 id="求左边第一个比它小的元素"><a href="#求左边第一个比它小的元素" class="headerlink" title="求左边第一个比它小的元素"></a>求左边第一个比它小的元素</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st; <span class="comment">// 单调递增栈，存下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; a[st.<span class="built_in">top</span>()]&gt;=a[i]) st.<span class="built_in">pop</span>();</span><br><span class="line">        ans[i]=st.<span class="built_in">empty</span>()? <span class="number">-1</span>: st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大矩形面积（柱状图）"><a href="#最大矩形面积（柱状图）" class="headerlink" title="最大矩形面积（柱状图）"></a>最大矩形面积（柱状图）</h3><p>给定 $n$ 个柱子的高度，求能构成的最大矩形面积。</p>
<p><strong>思路</strong>：对每个柱子，找左右第一个比它矮的位置，宽度即为两位置之间距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">lgstRectangle</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=h.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n)</span>, <span class="title">r</span><span class="params">(n)</span></span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左边第一个更小的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; h[st.<span class="built_in">top</span>()]&gt;=h[i]) st.<span class="built_in">pop</span>();</span><br><span class="line">        l[i]=st.<span class="built_in">empty</span>()? <span class="number">0</span>: st.<span class="built_in">top</span>()<span class="number">+1</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) st.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右边第一个更小的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; h[st.<span class="built_in">top</span>()]&gt;=h[i]) st.<span class="built_in">pop</span>();</span><br><span class="line">        r[i]=st.<span class="built_in">empty</span>()? n<span class="number">-1</span>: st.<span class="built_in">top</span>()<span class="number">-1</span>;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans, (ll)h[i]*(r[i]-l[i]<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>维护一个单调队列，用于求<strong>滑动窗口最值</strong>。</p>
<p>队列保持单调性，队首为当前窗口的最值。每次移动窗口时，检查队首是否过期，队尾是否需要弹出。</p>
<h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; q; <span class="comment">// 存下标，单调递减</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 移除过期元素</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>()&lt;=i-k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="comment">// 维护单调性</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; a[q.<span class="built_in">back</span>()]&lt;=a[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">        q.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>) ans.<span class="built_in">push_back</span>(a[q.<span class="built_in">front</span>()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列优化DP"><a href="#单调队列优化DP" class="headerlink" title="单调队列优化DP"></a>单调队列优化DP</h3><p>例：跳台阶，每次可跳 $[1,k]$ 步，第 $i$ 个台阶代价为 $c_i$，求最小总代价。</p>
<p>$dp[i]=\min(dp[j])+c[i],\ j\in[i-k,i-1]$，用单调队列维护区间最小值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, k, c[N];</span><br><span class="line">ll dp[N];</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>()&lt;i-k) q.<span class="built_in">pop_front</span>();</span><br><span class="line">    dp[i]=dp[q.<span class="built_in">front</span>()]+c[i];</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; dp[q.<span class="built_in">back</span>()]&gt;=dp[i]) q.<span class="built_in">pop_back</span>();</span><br><span class="line">    q.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h2><p>将树分解成若干条链，支持<strong>树上路径修改、查询</strong>，时间复杂度 $O(\log^2 n)$。</p>
<p>两次DFS，第一次求子树大小和重儿子，第二次划分重链。路径操作转化为链上的线段树操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[N];</span><br><span class="line"><span class="type">int</span> sz[N], dep[N], fa[N], son[N]; <span class="comment">// 子树大小、深度、父节点、重儿子</span></span><br><span class="line"><span class="type">int</span> top[N], id[N], rk[N], cnt; <span class="comment">// 链顶、DFS序、DFS序对应节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>; fa[u]=f; dep[u]=dep[f]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: tree[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v, u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[v]&gt;sz[son[u]]) son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u]=t; id[u]=++cnt; rk[cnt]=u;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u], t); <span class="comment">// 重儿子继承链顶</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=fa[u] &amp;&amp; v!=son[u])</span><br><span class="line">            <span class="built_in">dfs2</span>(v, v); <span class="comment">// 轻儿子开启新链</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线段树部分（维护和）</span></span><br><span class="line">ll tree_seg[N&lt;&lt;<span class="number">2</span>], lazy[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;tree_seg[rt]=a[rk[l]]; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(l, m, rt&lt;&lt;<span class="number">1</span>); <span class="built_in">build</span>(m<span class="number">+1</span>, r, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    tree_seg[rt]=tree_seg[rt&lt;&lt;<span class="number">1</span>]+tree_seg[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> rt, <span class="type">int</span> ln, <span class="type">int</span> rn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazy[rt])</span><br><span class="line">    &#123;</span><br><span class="line">        lazy[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt]; lazy[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt];</span><br><span class="line">        tree_seg[rt&lt;&lt;<span class="number">1</span>]+=lazy[rt]*ln; tree_seg[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[rt]*rn;</span><br><span class="line">        lazy[rt]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, ll val, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R) &#123;tree_seg[rt]+=val*(r-l<span class="number">+1</span>); lazy[rt]+=val; <span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt, m-l<span class="number">+1</span>, r-m);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m) <span class="built_in">update</span>(L, R, val, l, m, rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m) <span class="built_in">update</span>(L, R, val, m<span class="number">+1</span>, r, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    tree_seg[rt]=tree_seg[rt&lt;&lt;<span class="number">1</span>]+tree_seg[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l &amp;&amp; r&lt;=R) <span class="keyword">return</span> tree_seg[rt];</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt, m-l<span class="number">+1</span>, r-m);</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=m) res+=<span class="built_in">query</span>(L, R, l, m, rt&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(R&gt;m) res+=<span class="built_in">query</span>(L, R, m<span class="number">+1</span>, r, rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径修改</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pathUpdate</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        <span class="built_in">update</span>(id[top[u]], id[u], val, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="built_in">update</span>(id[u], id[v], val, <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径查询</span></span><br><span class="line"><span class="function">ll <span class="title">pathQuery</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">        res+=<span class="built_in">query</span>(id[top[u]], id[u], <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    res+=<span class="built_in">query</span>(id[u], id[v], <span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">dfs1(1, 0);</span></span><br><span class="line"><span class="comment">dfs2(1, 1);</span></span><br><span class="line"><span class="comment">build(1, n, 1);</span></span><br><span class="line"><span class="comment">pathUpdate(u, v, val);</span></span><br><span class="line"><span class="comment">ll ans=pathQuery(u, v);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="主席树（可持久化线段树）"><a href="#主席树（可持久化线段树）" class="headerlink" title="主席树（可持久化线段树）"></a>主席树（可持久化线段树）</h2><p>支持查询<strong>历史版本</strong>的线段树，常用于求<strong>区间第k小</strong>。</p>
<p><strong>思路</strong>：每次修改不直接改原树，而是新建节点。利用函数式编程思想，不同版本共享未修改的子树。</p>
<h3 id="区间第k小"><a href="#区间第k小" class="headerlink" title="区间第k小"></a>区间第k小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">int</span> n, m, a[N], b[N], cnt;</span><br><span class="line"><span class="type">int</span> root[N], ls[N*<span class="number">40</span>], rs[N*<span class="number">40</span>], sum[N*<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=++cnt;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    ls[rt]=<span class="built_in">build</span>(l, m);</span><br><span class="line">    rs[rt]=<span class="built_in">build</span>(m<span class="number">+1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">update</span><span class="params">(<span class="type">int</span> pre, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> rt=++cnt;</span><br><span class="line">    ls[rt]=ls[pre]; rs[rt]=rs[pre]; sum[rt]=sum[pre]<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> rt;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=m) ls[rt]=<span class="built_in">update</span>(ls[pre], l, m, x);</span><br><span class="line">    <span class="keyword">else</span> rs[rt]=<span class="built_in">update</span>(rs[pre], m<span class="number">+1</span>, r, x);</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x=sum[ls[v]]-sum[ls[u]];</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=x) <span class="keyword">return</span> <span class="built_in">query</span>(ls[u], ls[v], l, m, k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rs[u], rs[v], m<span class="number">+1</span>, r, k-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="comment">for(int i=1; i&lt;=n; i++) b[i]=a[i];</span></span><br><span class="line"><span class="comment">sort(b+1, b+n+1);</span></span><br><span class="line"><span class="comment">int len=unique(b+1, b+n+1)-b-1;</span></span><br><span class="line"><span class="comment">for(int i=1; i&lt;=n; i++) a[i]=lower_bound(b+1, b+len+1, a[i])-b;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 建树</span></span><br><span class="line"><span class="comment">root[0]=build(1, len);</span></span><br><span class="line"><span class="comment">for(int i=1; i&lt;=n; i++)</span></span><br><span class="line"><span class="comment">    root[i]=update(root[i-1], 1, len, a[i]);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 查询[l,r]区间第k小</span></span><br><span class="line"><span class="comment">int ans=query(root[l-1], root[r], 1, len, k);</span></span><br><span class="line"><span class="comment">cout&lt;&lt;b[ans]&lt;&lt;endl; // 还原真实值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="分块算法"><a href="#分块算法" class="headerlink" title="分块算法"></a>分块算法</h2><p>将序列分成 $\sqrt{n}$ 块，块内暴力，块间优化，时间复杂度 $O(n\sqrt{n})$。</p>
<p><strong>思路</strong>：设块长 $B=\sqrt{n}$，预处理每块的信息。查询时，完整块直接用预处理结果，不完整块暴力。</p>
<h3 id="区间加、区间查询和"><a href="#区间加、区间查询和" class="headerlink" title="区间加、区间查询和"></a>区间加、区间查询和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, B, a[N], belong[N]; <span class="comment">// belong[i]表示i属于哪个块</span></span><br><span class="line">ll sum[N], add[N]; <span class="comment">// sum[i]为第i块的和，add[i]为第i块的加法标记</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        belong[i]=(i<span class="number">-1</span>)/B<span class="number">+1</span>;</span><br><span class="line">        sum[belong[i]]+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(belong[l]==belong[r]) <span class="comment">// 同一块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) a[i]+=val, sum[belong[i]]+=val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左端不完整块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; belong[i]==belong[l]; i++) a[i]+=val, sum[belong[i]]+=val;</span><br><span class="line">    <span class="comment">// 右端不完整块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r; belong[i]==belong[r]; i--) a[i]+=val, sum[belong[i]]+=val;</span><br><span class="line">    <span class="comment">// 中间完整块</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=belong[l]<span class="number">+1</span>; i&lt;belong[r]; i++) add[i]+=val, sum[i]+=val*B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(belong[l]==belong[r])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l; i&lt;=r; i++) res+=a[i]+add[belong[i]];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l; belong[i]==belong[l]; i++) res+=a[i]+add[belong[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r; belong[i]==belong[r]; i--) res+=a[i]+add[belong[i]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=belong[l]<span class="number">+1</span>; i&lt;belong[r]; i++) res+=sum[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡树（Treap）"><a href="#平衡树（Treap）" class="headerlink" title="平衡树（Treap）"></a>平衡树（Treap）</h2><p>支持插入、删除、查询第k小、查询排名等操作，时间复杂度 $O(\log n)$。</p>
<p>结合BST和堆的性质，键值满足BST，优先级满足堆，通过旋转维护平衡。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Treap</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r, val, key, size;</span><br><span class="line">    &#125;t[N];</span><br><span class="line">    <span class="type">int</span> cnt, root;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">newNode</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t[++cnt]=&#123;<span class="number">0</span>, <span class="number">0</span>, val, <span class="built_in">rand</span>(), <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        t[p].size=t[t[p].l].size+t[t[p].r].size<span class="number">+1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!x || !y) <span class="keyword">return</span> x+y;</span><br><span class="line">        <span class="keyword">if</span>(t[x].key&lt;t[y].key)</span><br><span class="line">        &#123;</span><br><span class="line">            t[x].r=<span class="built_in">merge</span>(t[x].r, y);</span><br><span class="line">            <span class="built_in">update</span>(x);</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t[y].l=<span class="built_in">merge</span>(x, t[y].l);</span><br><span class="line">            <span class="built_in">update</span>(y);</span><br><span class="line">            <span class="keyword">return</span> y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> val, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p) &#123;x=y=<span class="number">0</span>; <span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(t[p].val&lt;=val)</span><br><span class="line">        &#123;</span><br><span class="line">            x=p;</span><br><span class="line">            <span class="built_in">split</span>(t[p].r, val, t[p].r, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            y=p;</span><br><span class="line">            <span class="built_in">split</span>(t[p].l, val, x, t[p].l);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">update</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">split</span>(root, val, x, y);</span><br><span class="line">        root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x, <span class="built_in">newNode</span>(val)), y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">split</span>(root, val, x, z);</span><br><span class="line">        <span class="built_in">split</span>(x, val<span class="number">-1</span>, x, y);</span><br><span class="line">        y=<span class="built_in">merge</span>(t[y].l, t[y].r);</span><br><span class="line">        root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(x, y), z);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> val)</span> <span class="comment">// 查询val的排名</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">split</span>(root, val<span class="number">-1</span>, x, y);</span><br><span class="line">        <span class="type">int</span> res=t[x].size<span class="number">+1</span>;</span><br><span class="line">        root=<span class="built_in">merge</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> k)</span> <span class="comment">// 查询第k小</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[t[p].l].size<span class="number">+1</span>==k) <span class="keyword">return</span> t[p].val;</span><br><span class="line">            <span class="keyword">if</span>(t[t[p].l].size&gt;=k) p=t[p].l;</span><br><span class="line">            <span class="keyword">else</span> k-=t[t[p].l].size<span class="number">+1</span>, p=t[p].r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getPre</span><span class="params">(<span class="type">int</span> val)</span> <span class="comment">// 查询前驱</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">split</span>(root, val<span class="number">-1</span>, x, y);</span><br><span class="line">        <span class="type">int</span> p=x;</span><br><span class="line">        <span class="keyword">while</span>(t[p].r) p=t[p].r;</span><br><span class="line">        <span class="type">int</span> res=t[p].val;</span><br><span class="line">        root=<span class="built_in">merge</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNext</span><span class="params">(<span class="type">int</span> val)</span> <span class="comment">// 查询后继</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">split</span>(root, val, x, y);</span><br><span class="line">        <span class="type">int</span> p=y;</span><br><span class="line">        <span class="keyword">while</span>(t[p].l) p=t[p].l;</span><br><span class="line">        <span class="type">int</span> res=t[p].val;</span><br><span class="line">        root=<span class="built_in">merge</span>(x, y);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>注意数组必须有序！！！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断x是否满足条件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll l=<span class="number">-1</span>, r=LLONG_MAX;</span><br><span class="line"><span class="keyword">while</span>(l<span class="number">+1</span>!=r)</span><br><span class="line">&#123;</span><br><span class="line">    ll m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m)) l=m;</span><br><span class="line">    <span class="keyword">else</span> r=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找（浮点数）"><a href="#二分查找（浮点数）" class="headerlink" title="二分查找（浮点数）"></a>二分查找（浮点数）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>; <span class="comment">// 精度</span></span><br><span class="line"><span class="type">double</span> l=<span class="number">0</span>, r=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> m=(l+r)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m)) l=m;</span><br><span class="line">    <span class="keyword">else</span> r=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用固定循环次数（推荐，更稳定）</span></span><br><span class="line"><span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> m = (l+r)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">check</span>(m)) l=m;</span><br><span class="line">    <span class="keyword">else</span> r=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h2><p>用于在单峰函数（凸函数或凹函数）上寻找极值点，时间复杂度 $O(\log n)$ ，这里给出求最大值的代码，最小值改个条件即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求单峰函数的最大值点</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 目标函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">double</span> l=<span class="number">0</span>, r=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">while</span>(r-l&gt;eps)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> m1=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">    <span class="type">double</span> m2=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2)) l=m1;</span><br><span class="line">    <span class="keyword">else</span> r=m2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 最大值点在 [l,r] 区间内，可以取 (l+r)/2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用固定循环次数（推荐）</span></span><br><span class="line"><span class="type">double</span> l=<span class="number">0</span>, r=<span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> m1=l+(r-l)/<span class="number">3</span>;</span><br><span class="line">    <span class="type">double</span> m2=r-(r-l)/<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">f</span>(m1)&lt;<span class="built_in">f</span>(m2)) l=m1;</span><br><span class="line">    <span class="keyword">else</span> r=m2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="数论、几何、多项式"><a href="#数论、几何、多项式" class="headerlink" title="数论、几何、多项式"></a>数论、几何、多项式</h1><h2 id="常用公式-结论"><a href="#常用公式-结论" class="headerlink" title="常用公式/结论"></a>常用公式/结论</h2><h3 id="质因数分解相关"><a href="#质因数分解相关" class="headerlink" title="质因数分解相关"></a>质因数分解相关</h3><p>设 $n=\prod_{i=1}^{k}p_i^{q_i}$（$p_i$ 为质因子，$q_i$ 为指数）</p>
<ul>
<li><strong>因数个数</strong>：$d(n)=\prod_{i=1}^{k}(q_i+1)$</li>
<li><strong>因数和</strong>：$\sigma(n)=\prod<em>{i=1}^{k}\frac{p_i^{q_i+1}-1}{p_i-1}=\prod</em>{i=1}^{k}(1+p_i+p_i^2+\cdots+p_i^{q_i})$</li>
<li><strong>欧拉函数</strong>：$\varphi(n)=n\prod<em>{i=1}^{k}(1-\frac{1}{p_i})=n\prod</em>{i=1}^{k}\frac{p_i-1}{p_i}$</li>
<li><strong>莫比乌斯函数</strong>：<ul>
<li>若存在 $q_i&gt;1$，则 $\mu(n)=0$</li>
<li>否则 $\mu(n)=(-1)^k$</li>
</ul>
</li>
<li><strong>最大公约数</strong>：$\gcd(a,b)=\prod p_i^{\min(q_i^a, q_i^b)}$</li>
<li><strong>最小公倍数</strong>：$\text{lcm}(a,b)=\prod p_i^{\max(q_i^a, q_i^b)}$</li>
</ul>
<h3 id="基本定理"><a href="#基本定理" class="headerlink" title="基本定理"></a>基本定理</h3><ul>
<li><strong>裴蜀定理</strong>：对于任意整数 $a,b$，存在整数 $x,y$ 使得 $ax+by=\gcd(a,b)$</li>
<li><strong>费马小定理</strong>：若 $p$ 为质数，$\gcd(a,p)=1$，则 $a^{p-1}\equiv 1 \pmod{p}$</li>
<li><strong>欧拉定理</strong>：若 $\gcd(a,n)=1$，则 $a^{\varphi(n)}\equiv 1 \pmod{n}$</li>
<li><strong>威尔逊定理</strong>：$p$ 为质数当且仅当 $(p-1)! \equiv -1 \pmod{p}$</li>
<li><strong>中国剩余定理</strong>：若 $m_1,m_2,\ldots,m_k$ 两两互质，则同余方程组有唯一解</li>
</ul>
<h3 id="欧拉函数性质"><a href="#欧拉函数性质" class="headerlink" title="欧拉函数性质"></a>欧拉函数性质</h3><ul>
<li>$\varphi(1)=1$</li>
<li>$\varphi(p)=p-1$（$p$ 为质数）</li>
<li>$\varphi(p^k)=p^{k-1}(p-1)$（$p$ 为质数）</li>
<li>若 $\gcd(m,n)=1$，则 $\varphi(mn)=\varphi(m)\varphi(n)$（积性函数）</li>
<li>$\sum_{d|n}\varphi(d)=n$</li>
</ul>
<h3 id="莫比乌斯函数性质"><a href="#莫比乌斯函数性质" class="headerlink" title="莫比乌斯函数性质"></a>莫比乌斯函数性质</h3><ul>
<li>$\mu(1)=1$</li>
<li>若 $\gcd(m,n)=1$，则 $\mu(mn)=\mu(m)\mu(n)$（积性函数）</li>
<li>$\sum_{d|n}\mu(d)=\begin{cases}1 &amp; n=1 \ 0 &amp; n&gt;1\end{cases}$</li>
<li><strong>莫比乌斯反演</strong>：<ul>
<li>$f(n)=\sum<em>{d|n}g(d) \Leftrightarrow g(n)=\sum</em>{d|n}\mu(d)f(\frac{n}{d})$</li>
<li>$f(n)=\sum<em>{n|d}g(d) \Leftrightarrow g(n)=\sum</em>{n|d}\mu(\frac{d}{n})f(d)$</li>
</ul>
</li>
</ul>
<h3 id="同余性质"><a href="#同余性质" class="headerlink" title="同余性质"></a>同余性质</h3><ul>
<li>$(a+b)\bmod m=(a\bmod m+b\bmod m)\bmod m$</li>
<li>$(a-b)\bmod m=(a\bmod m-b\bmod m)\bmod m$</li>
<li>$(a\times b)\bmod m=(a\bmod m\times b\bmod m)\bmod m$</li>
<li>$a\equiv b \pmod{m} \Rightarrow ac\equiv bc \pmod{m}$</li>
<li>若 $\gcd(c,m)=1$，则 $ac\equiv bc \pmod{m} \Rightarrow a\equiv b \pmod{m}$</li>
</ul>
<h3 id="组合数性质"><a href="#组合数性质" class="headerlink" title="组合数性质"></a>组合数性质</h3><ul>
<li>$C_n^m=C_n^{n-m}$</li>
<li>$C<em>n^m=C</em>{n-1}^{m-1}+C_{n-1}^{m}$（杨辉三角）</li>
<li>$\sum_{i=0}^{n}C_n^i=2^n$</li>
<li><strong>Lucas定理</strong>：$C<em>n^m \equiv C</em>{n/p}^{m/p} \cdot C_{n\bmod p}^{m\bmod p} \pmod{p}$（$p$ 为质数）</li>
</ul>
<h3 id="其他常用结论"><a href="#其他常用结论" class="headerlink" title="其他常用结论"></a>其他常用结论</h3><ul>
<li><strong>质数个数</strong>：不超过 $n$ 的质数约有 $\frac{n}{\ln n}$ 个</li>
<li><strong>1到n的质数个数</strong>：$\pi(n) \sim \frac{n}{\ln n}$</li>
</ul>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><ul>
<li>不带模的快速幂</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a^b</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a;</span><br><span class="line">        a=a*a;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带模的快速幂</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a^b % mod</span></span><br><span class="line"><span class="function">ll <span class="title">qpowm</span><span class="params">(ll a, ll b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>%mod;</span><br><span class="line">    a%=mod;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%mod;</span><br><span class="line">        a=a*a%mod;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">matrix_mul</span>(vector&lt;vector&lt;ll&gt;&gt; &amp;a,vector&lt;vector&lt;ll&gt;&gt; &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>(), p=b.<span class="built_in">size</span>(), m=b[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">c</span>(n,<span class="built_in">vector</span>&lt;ll&gt;(m,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;p; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][k]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span><br><span class="line">                c[i][j]=(c[i][j]<span class="number">+1LL</span>*a[i][k]*b[k][j])%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">qpow</span>(vector&lt;vector&lt;ll&gt;&gt; &amp;a, ll p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;ll&gt;(n,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) res[i][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p&amp;<span class="number">1</span>) res=<span class="built_in">matrix_mul</span>(res,a);</span><br><span class="line">        a=<span class="built_in">matrix_mul</span>(a,a);</span><br><span class="line">        p&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pii <span class="title">exgcd</span><span class="params">(ll a, ll b, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a==<span class="number">0</span>)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(c%a!=<span class="number">0</span>)<span class="keyword">return</span> &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;c/a,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> [x1,y1]=<span class="built_in">exgcd</span>(b,a%b,c);</span><br><span class="line">    <span class="keyword">return</span> &#123;y1,x1-(a/b)*y1&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h2><script type="math/tex; mode=display">
a \times x \equiv 1 \pmod{p} \ \Longrightarrow \ x = a^{-1} \pmod{p}</script><p>乘法逆元存在的条件：$\gcd(a, m) = 1$，即 $a$ 与 $m$ 互质</p>
<h3 id="快速幂求逆元（费马小定理）"><a href="#快速幂求逆元（费马小定理）" class="headerlink" title="快速幂求逆元（费马小定理）"></a>快速幂求逆元（费马小定理）</h3><p><strong>限制</strong>：要求 $m$ 为质数，且 $\gcd(a, m) = 1$</p>
<p>费马小定理：当 $p$ 为质数时，$a^{p-1} \equiv 1 \pmod{p}$，因此 $a^{-1} \equiv a^{p-2} \pmod{p}$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll b, ll exp, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    b%=mod;</span><br><span class="line">    <span class="keyword">while</span>(exp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)</span><br><span class="line">            res=(res*b)%mod;</span><br><span class="line">        b=(b*b)%mod;</span><br><span class="line">        exp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mod_inverse</span><span class="params">(ll a, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, m - <span class="number">2</span>, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展欧几里得求逆元"><a href="#扩展欧几里得求逆元" class="headerlink" title="扩展欧几里得求逆元"></a>扩展欧几里得求逆元</h3><p><strong>通用方法</strong>，适用于任意模数</p>
<p>原理：通过扩展欧几里得算法求解 $ax + my = 1$，得到 $ax \equiv 1 \pmod{m}$，即 $x$ 为 $a$ 在模 $m$ 意义下的逆元。当 $\gcd(a, m) \neq 1$ 时逆元不存在。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>, y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g=<span class="built_in">exgcd</span>(b, a%b, y, x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">mod_inverse</span><span class="params">(ll a, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x, y;</span><br><span class="line">    ll g=<span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">    <span class="keyword">if</span>(g!=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 逆元不存在</span></span><br><span class="line">    <span class="keyword">return</span> (x%m+m)%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h3><p>求1到n所有数的逆元，<strong>限制</strong>：要求 $\mathbf{mod}$ 为质数</p>
<p>时间复杂度 $O(n)$，适用于需要大量逆元的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">line_inv</span><span class="params">(<span class="type">int</span> n, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">inv</span><span class="params">(n<span class="number">+1</span>)</span></span>;</span><br><span class="line">    inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        inv[i]=(mod-mod/i)*inv[mod%i]%mod;</span><br><span class="line">    <span class="keyword">return</span> inv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><script type="math/tex; mode=display">
\left\{\begin{aligned}
x &\equiv a_1 \pmod{m_1} \\
x &\equiv a_2 \pmod{m_2} \\
&\vdots \\
x &\equiv a_n \pmod{m_n}
\end{aligned}\right.</script><p>解为：</p>
<script type="math/tex; mode=display">
x \equiv \sum_{i=1}^{n} a_i M_i y_i \pmod{M}</script><p>其中 $M=\prod_{i=1}^{n} m_i$，$M_i=M/m_i$，$y_i \equiv M_i^{-1} \pmod{m_i}$</p>
<h3 id="模数两两互质"><a href="#模数两两互质" class="headerlink" title="模数两两互质"></a>模数两两互质</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>, y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">CRT</span><span class="params">(vector&lt;ll&gt; &amp;a, vector&lt;ll&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll M=<span class="number">1</span>, res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;mi: m) M*=mi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll Mi=M/m[i], x, y;</span><br><span class="line">        <span class="built_in">exgcd</span>(Mi,m[i],x,y);</span><br><span class="line">        x=(x%M+M)%M;</span><br><span class="line">        res=(res+a[i]*Mi%M*x%M)%M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模数不两两互质"><a href="#模数不两两互质" class="headerlink" title="模数不两两互质"></a>模数不两两互质</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>, y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ll g=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">exCRT</span><span class="params">(vector&lt;ll&gt; &amp;a, vector&lt;ll&gt; &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x=a[<span class="number">0</span>], M=m[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a2=a[i], m2=m[i];</span><br><span class="line">        ll c=(a2-x%m2+m2)%m2, g=__gcd(M,m2);</span><br><span class="line">        <span class="keyword">if</span>(c%g!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// solve k*M=c(mod m2)</span></span><br><span class="line">        ll k, t;</span><br><span class="line">        <span class="built_in">exgcd</span>(M,m2,k,t);</span><br><span class="line">        k=k*(c/g)%(m2/g);</span><br><span class="line">        k=(k%(m2/g)+(m2/g))%(m2/g);</span><br><span class="line">        x=x+k*M;</span><br><span class="line">        M=M/g*m2;</span><br><span class="line">        x%=M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h2><script type="math/tex; mode=display">
n=\prod_{i=1}^{k}p_i^{q_i}</script><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>时间复杂度 $O(\sqrt{n})$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; p, q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=n; i++)<span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(n%i==<span class="number">0</span>)j++, n/=i;</span><br><span class="line">    p.<span class="built_in">push_back</span>(i); q.<span class="built_in">push_back</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    p.<span class="built_in">push_back</span>(n);</span><br><span class="line">    q.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速方法"><a href="#快速方法" class="headerlink" title="快速方法"></a>快速方法</h3><p>时间复杂度 $O(\frac{\sqrt{n}}{\ln n})$，需要预处理质数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; primes;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sieve</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!not_prime[i]) primes.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p: primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i*p&gt;n) <span class="keyword">break</span>;</span><br><span class="line">            not_prime[i*p]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%p==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 质因数分解</span></span><br><span class="line"><span class="function">vector&lt;pii&gt; <span class="title">factorize</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;pii&gt; res; <span class="comment">// &#123;质因子, 指数&#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> p: primes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">1LL</span>*p*p&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(n%p==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%p==<span class="number">0</span>) n/=p, cnt++;</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;p, cnt&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) res.<span class="built_in">push_back</span>(&#123;n, <span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Pollard’s-Rho-算法（大数分解）"><a href="#Pollard’s-Rho-算法（大数分解）" class="headerlink" title="Pollard’s Rho 算法（大数分解）"></a>Pollard’s Rho 算法（大数分解）</h3><p>时间复杂度 $O(n^{1/4})$，适用于 $n \le 10^{18}$ 的大数分解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b? <span class="built_in">gcd</span>(b, a%b): a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘（防止溢出）</span></span><br><span class="line"><span class="function">ll <span class="title">mul</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__int128)a*b%m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂</span></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=<span class="built_in">mul</span>(res, a, m);</span><br><span class="line">        a=<span class="built_in">mul</span>(a, a, m);</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Miller-Rabin 素性测试</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">miller_rabin</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">3</span> || n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> n==<span class="number">2</span>;</span><br><span class="line">    ll u=n<span class="number">-1</span>, t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(u%<span class="number">2</span>==<span class="number">0</span>) u/=<span class="number">2</span>, t++;</span><br><span class="line">    ll test[]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(ll a: test)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==a) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        ll v=<span class="built_in">qpow</span>(a, u, n);</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">1</span> || v==n<span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;t; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            v=<span class="built_in">mul</span>(v, v, n);</span><br><span class="line">            <span class="keyword">if</span>(v==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(v!=n<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pollard&#x27;s Rho 算法找因子</span></span><br><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll c=<span class="built_in">rand</span>()%(n<span class="number">-1</span>)<span class="number">+1</span>;</span><br><span class="line">    ll x=<span class="built_in">rand</span>()%n, y=x, d=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; d==<span class="number">1</span>; i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            x=(<span class="built_in">mul</span>(x, x, n)+c)%n;</span><br><span class="line">            d=<span class="built_in">gcd</span>(<span class="built_in">abs</span>(x-y), n);</span><br><span class="line">            <span class="keyword">if</span>(d&gt;<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d==n? <span class="built_in">pollard_rho</span>(n): d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归分解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">factorize</span><span class="params">(ll n, map&lt;ll,<span class="type">int</span>&gt; &amp;factors)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">miller_rabin</span>(n))</span><br><span class="line">    &#123;</span><br><span class="line">        factors[n]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll d=<span class="built_in">pollard_rho</span>(n);</span><br><span class="line">    <span class="built_in">factorize</span>(d, factors);</span><br><span class="line">    <span class="built_in">factorize</span>(n/d, factors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用例子：</span></span><br><span class="line"><span class="comment">map&lt;ll,int&gt; factors;</span></span><br><span class="line"><span class="comment">factorize(n, factors);</span></span><br><span class="line"><span class="comment">for(auto [p, cnt]: factors)</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;p&lt;&lt;&quot;^&quot;&lt;&lt;cnt&lt;&lt;&quot; &quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="线筛质数、欧拉、莫比乌斯"><a href="#线筛质数、欧拉、莫比乌斯" class="headerlink" title="线筛质数、欧拉、莫比乌斯"></a>线筛质数、欧拉、莫比乌斯</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line">vector&lt;ll&gt; pri;</span><br><span class="line"><span class="type">bool</span> not_prime[N];</span><br><span class="line">ll phi[N],mu[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  mu[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">2</span>; i&lt;=n; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(!not_prime[i])</span><br><span class="line">    &#123;</span><br><span class="line">        pri.<span class="built_in">push_back</span>(i);</span><br><span class="line">        phi[i]=i<span class="number">-1</span>;</span><br><span class="line">        mu[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(ll p : pri)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i*p&gt;n) <span class="keyword">break</span>;</span><br><span class="line">        not_prime[i*p]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i%p == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            phi[i*p]=phi[i]*p;</span><br><span class="line">            mu[i*p]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        phi[i*p]=phi[i]*phi[p];</span><br><span class="line">        mu[i*p]=-mu[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><p>欧拉函数 $\varphi(n)$ 表示小于等于 $n$ 的正整数中与 $n$ 互质的数的个数</p>
<p>性质：$\varphi(n) = n \prod_{p|n} (1-\frac{1}{p})$，其中 $p$ 为 $n$ 的质因子</p>
<h3 id="单个数"><a href="#单个数" class="headerlink" title="单个数"></a>单个数</h3><p>时间复杂度 $O(\sqrt{n})$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>; i*i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) res=res/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h3><p>时间复杂度 $O(n)$，见上面的”线筛质数、欧拉、莫比乌斯”部分</p>
<h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><p>莫比乌斯函数 $\mu(n)$ 的定义：</p>
<ul>
<li>$\mu(1) = 1$</li>
<li>$\mu(n) = 0$，若 $n$ 含有平方因子</li>
<li>$\mu(n) = (-1)^k$，若 $n$ 为 $k$ 个不同质因子的乘积</li>
</ul>
<h3 id="单个数-1"><a href="#单个数-1" class="headerlink" title="单个数"></a>单个数</h3><p>时间复杂度 $O(\sqrt{n})$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">mu</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>, cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>; i*i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i, t++;</span><br><span class="line">            <span class="keyword">if</span>(t&gt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 含有平方因子</span></span><br><span class="line">            cnt++; <span class="comment">// 质因子个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) cnt++; </span><br><span class="line">    <span class="keyword">return</span> (cnt&amp;<span class="number">1</span>)? -res: res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量-1"><a href="#批量-1" class="headerlink" title="批量"></a>批量</h3><p>时间复杂度 $O(n)$，见上面的”线筛质数、欧拉、莫比乌斯”部分</p>
<h2 id="快速组合数"><a href="#快速组合数" class="headerlink" title="快速组合数"></a>快速组合数</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理阶乘和阶乘逆元（适用于多次查询）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ll MOD = <span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">fac</span><span class="params">(MAXN)</span>, <span class="title">ifac</span><span class="params">(MAXN)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll b, ll exp, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    b%=mod;</span><br><span class="line">    <span class="keyword">while</span>(exp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)</span><br><span class="line">            res=(res*b)%mod;</span><br><span class="line">        b=(b*b)%mod;</span><br><span class="line">        exp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fac[i]=(fac[i<span class="number">-1</span>]*i)%MOD;</span><br><span class="line">    ifac[n]=<span class="built_in">qpow</span>(fac[n], MOD<span class="number">-2</span>, MOD);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) ifac[i]=(ifac[i<span class="number">+1</span>]*(i<span class="number">+1</span>))%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C_n^m</span></span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m&lt;<span class="number">0</span> || m&gt;n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*ifac[m]%MOD*ifac[n-m]%MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p>适用于大数组合数模小质数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll b, ll exp, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    b%=mod;</span><br><span class="line">    <span class="keyword">while</span>(exp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)</span><br><span class="line">            res=(res*b)%mod;</span><br><span class="line">        b=(b*b)%mod;</span><br><span class="line">        exp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">small</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span> || n&gt;m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || n==m) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    ll a=<span class="number">1</span>, b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a=a*(m-i<span class="number">+1</span>)%p;</span><br><span class="line">        b=(b*i)%p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a*<span class="built_in">qpow</span>(b, p<span class="number">-2</span>, p)%p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">Lucas</span><span class="params">(ll m, ll n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">small</span>(m%p, n%p, p)*<span class="built_in">Lucas</span>(m/p, n/p, p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉降幂"><a href="#欧拉降幂" class="headerlink" title="欧拉降幂"></a>欧拉降幂</h2><p>用于计算 $a^b \bmod m$，当 $b$ 非常大时（可能无法直接存储）</p>
<script type="math/tex; mode=display">
a^b\equiv\left\{\begin{matrix}
 a^{b\bmod\varphi(m)} & \pmod{m}, & \gcd(a, m)= 1\\
 a^b & \pmod{m}, & \gcd(a, m)\neq 1 \land b <\varphi(m)\\
 a^{(b\bmod\varphi(m))+\varphi(m)} & \pmod{m}, & \gcd(a, m)\neq 1 \land b\ge\varphi(m)
\end{matrix}\right.</script><h3 id="通用模板"><a href="#通用模板" class="headerlink" title="通用模板"></a>通用模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">phi</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=n;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">2</span>; i*i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res=res/i*(i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) res=res/n*(n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>%m;</span><br><span class="line">    a%=m;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%m;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 欧拉降幂</span></span><br><span class="line"><span class="function">ll <span class="title">euler_pow</span><span class="params">(ll a, ll b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ph=<span class="built_in">phi</span>(m);</span><br><span class="line">    <span class="keyword">if</span>(b&lt;ph) <span class="keyword">return</span> <span class="built_in">qpow</span>(a, b, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, b%ph+ph, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当b以字符串形式给出时</span></span><br><span class="line"><span class="function">ll <span class="title">euler_pow_str</span><span class="params">(ll a, string b, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ll ph=<span class="built_in">phi</span>(m);</span><br><span class="line"></span><br><span class="line">    ll mod_b=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> large=<span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: b)</span><br><span class="line">    &#123;</span><br><span class="line">        mod_b=mod_b*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(mod_b&gt;=ph) large=<span class="literal">true</span>;</span><br><span class="line">        mod_b%=ph;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断原始b是否&gt;=ph（需要比较字符串）</span></span><br><span class="line">    <span class="keyword">if</span>(!large)</span><br><span class="line">    &#123;</span><br><span class="line">        ll realb=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: b)</span><br><span class="line">        &#123;</span><br><span class="line">            realb=realb*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(realb&gt;=ph) &#123;large=<span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(large) <span class="keyword">return</span> <span class="built_in">qpow</span>(a, mod_b+ph, m);</span><br><span class="line">    </span><br><span class="line">    ll realb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: b) realb=realb*<span class="number">10</span>+(c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, realb, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用例子：</span></span><br><span class="line"><span class="comment">cout&lt;&lt;euler_pow(2, 1000000000, 1000000007)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 若b是字符串</span></span><br><span class="line"><span class="comment">string b=&quot;123456789012345678901234567890&quot;;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;euler_pow_str(2, b, 1000000007)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="幂塔问题（扩展）"><a href="#幂塔问题（扩展）" class="headerlink" title="幂塔问题（扩展）"></a>幂塔问题（扩展）</h3><p>计算 $a^{a^{a^{\cdots}}} \bmod m$（递归幂塔）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">power_tower</span><span class="params">(ll a, ll cnt, ll m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>%m;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>%m;</span><br><span class="line">    </span><br><span class="line">    ll ph=<span class="built_in">phi</span>(m);</span><br><span class="line">    ll exp=<span class="built_in">power_tower</span>(a, cnt<span class="number">-1</span>, ph);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断 a^exp 是否 &gt;= m</span></span><br><span class="line">    <span class="type">bool</span> large=<span class="literal">false</span>;</span><br><span class="line">    ll tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;exp; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp*=a;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=m) &#123;large=<span class="literal">true</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(large) <span class="keyword">return</span> <span class="built_in">qpow</span>(a, exp%ph+ph, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">qpow</span>(a, exp, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">计算 2^2^2^2 mod 1000000007</span></span><br><span class="line"><span class="comment">cout&lt;&lt;power_tower(2, 4, 1000000007)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>解 $n$ 元线性方程组 $Ax=b$，其中 $A$ 是 $n\times n$ 矩阵。</p>
<p>通过初等行变换将增广矩阵 $[A|b]$ 化为上三角形式，再回代求解。时间复杂度 $O(n^3)$。</p>
<h3 id="浮点数版本"><a href="#浮点数版本" class="headerlink" title="浮点数版本"></a>浮点数版本</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-9</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[N][N]; <span class="comment">// 增广矩阵 [A|b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：0-唯一解，1-无解，2-无穷多解</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>; <span class="comment">// 当前处理到第几行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>; c&lt;n; c++) <span class="comment">// 枚举列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r; i&lt;n; i++) <span class="comment">// 找主元</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c])&gt;<span class="built_in">fabs</span>(a[t][c])) t=i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[t][c])&lt;eps) <span class="keyword">continue</span>; <span class="comment">// 主元为0，跳过此列</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=c; i&lt;=n; i++) <span class="built_in">swap</span>(a[t][i], a[r][i]); <span class="comment">// 交换行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=c; i--) a[r][i]/=a[r][c]; <span class="comment">// 首项化为1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r<span class="number">+1</span>; i&lt;n; i++) <span class="comment">// 消元</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][c])&gt;eps)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=n; j&gt;=c; j--)</span><br><span class="line">                    a[i][j]-=a[r][j]*a[i][c];</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[i][n])&gt;eps) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 回代求解</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>; j&lt;n; j++)</span><br><span class="line">            a[i][n]-=a[i][j]*a[j][n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 唯一解在 a[i][n]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="整数版本（模意义）"><a href="#整数版本（模意义）" class="headerlink" title="整数版本（模意义）"></a>整数版本（模意义）</h3><p>求解 $Ax\equiv b \pmod{p}$，常用于求线性递推式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ll a[N][N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll MOD;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll b, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>; a%=p;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;<span class="keyword">if</span>(b&amp;<span class="number">1</span>) res=res*a%p; a=a*a%p; b&gt;&gt;=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> c=<span class="number">0</span>; c&lt;n; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][c]) &#123;t=i; <span class="keyword">break</span>;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!a[t][c]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=c; i&lt;=n; i++) <span class="built_in">swap</span>(a[t][i], a[r][i]);</span><br><span class="line">        ll inv=<span class="built_in">qpow</span>(a[r][c], MOD<span class="number">-2</span>, MOD);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=c; i&lt;=n; i++) a[r][i]=a[r][i]*inv%MOD;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r<span class="number">+1</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][c])</span><br><span class="line">            &#123;</span><br><span class="line">                ll t=a[i][c];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=c; j&lt;=n; j++)</span><br><span class="line">                    a[i][j]=(a[i][j]-t*a[r][j]%MOD+MOD)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=r; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(a[i][n]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>; j&lt;n; j++)</span><br><span class="line">            a[i][n]=(a[i][n]-a[i][j]*a[j][n]%MOD+MOD)%MOD;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求行列式"><a href="#求行列式" class="headerlink" title="求行列式"></a>求行列式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浮点数版</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">det</span><span class="params">(vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">double</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[j][i])&gt;<span class="built_in">fabs</span>(a[k][i])) k=j;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">fabs</span>(a[k][i])&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k!=i) res=-res, <span class="built_in">swap</span>(a[i], a[k]);</span><br><span class="line">        res*=a[i][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>; j&lt;n; j++) a[i][j]/=a[i][i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">+1</span>; k&lt;n; k++)</span><br><span class="line">                a[j][k]-=a[j][i]*a[i][k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整数版（模意义）</span></span><br><span class="line"><span class="function">ll <span class="title">det_mod</span><span class="params">(ll a[][N], <span class="type">int</span> n, ll p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>; j&lt;n; j++)</span><br><span class="line">            <span class="keyword">if</span>(a[j][i]) &#123;k=j; <span class="keyword">break</span>;&#125;</span><br><span class="line">        <span class="keyword">if</span>(!a[k][i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(k!=i) res=p-res, <span class="built_in">swap</span>(a[i], a[k]);</span><br><span class="line">        res=res*a[i][i]%p;</span><br><span class="line">        ll inv=<span class="built_in">qpow</span>(a[i][i], p<span class="number">-2</span>, p);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>; j&lt;n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ll t=a[j][i]*inv%p;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;n; k++)</span><br><span class="line">                a[j][k]=(a[j][k]-t*a[i][k]%p+p)%p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h2><p>用于处理<strong>异或线性组合</strong>问题，可以快速求解异或最大值、判断是否能异或出某个数等。</p>
<p>其中<strong>线性基</strong>是原数组的一个子集，满足：</p>
<ol>
<li>原数组任意子集的异或和都能由线性基的某个子集异或得到</li>
<li>线性基中任意子集的异或和都不为0</li>
<li>线性基中元素个数唯一且最少</li>
</ol>
<p>时间复杂度：插入 $O(\log V)$，查询 $O(\log V)$，其中 $V$ 为值域。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LB</span></span><br><span class="line">&#123;</span><br><span class="line">    ll d[<span class="number">65</span>]; <span class="comment">// d[i]表示最高位为i的数</span></span><br><span class="line">    <span class="type">int</span> cnt; <span class="comment">// 线性基中元素个数</span></span><br><span class="line">    <span class="type">bool</span> zero; <span class="comment">// 是否能异或出0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">LB</span>() &#123;<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d)); cnt=<span class="number">0</span>; zero=<span class="literal">false</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(x&amp;(<span class="number">1LL</span>&lt;&lt;i))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!d[i]) &#123;d[i]=x; cnt++; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">            x^=d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        zero=<span class="literal">true</span>; <span class="comment">// 异或出0，说明线性相关</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ll <span class="title">queryMax</span><span class="params">()</span> <span class="comment">// 查询最大异或和</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span>((res^d[i])&gt;res) res^=d[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ll <span class="title">queryMin</span><span class="params">()</span> <span class="comment">// 查询最小异或和（非0）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(zero) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">62</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(d[i]) <span class="keyword">return</span> d[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(ll x)</span> <span class="comment">// 判断能否异或出x</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(x&amp;(<span class="number">1LL</span>&lt;&lt;i))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!d[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            x^=d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="查询第k小异或和"><a href="#查询第k小异或和" class="headerlink" title="查询第k小异或和"></a>查询第k小异或和</h3><p>先将线性基改为简化阶梯形（上三角），然后按二进制枚举。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LB</span></span><br><span class="line">&#123;</span><br><span class="line">    ll d[<span class="number">65</span>], p[<span class="number">65</span>];</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="type">bool</span> zero;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">LB</span>() &#123;<span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d)); cnt=<span class="number">0</span>; zero=<span class="literal">false</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">insert</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(x&amp;(<span class="number">1LL</span>&lt;&lt;i))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(!d[i]) &#123;d[i]=x; cnt++; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line">            x^=d[i];</span><br><span class="line">        &#125;</span><br><span class="line">        zero=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">()</span> <span class="comment">// 重构为简化阶梯形</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">                <span class="keyword">if</span>(d[i]&amp;(<span class="number">1LL</span>&lt;&lt;j)) d[i]^=d[j];</span><br><span class="line">        </span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">62</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(d[i]) p[cnt++]=d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ll <span class="title">queryKth</span><span class="params">(ll k)</span> <span class="comment">// 查询第k小（k从1开始）</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(zero) k--; <span class="comment">// 如果能异或出0，0是最小的</span></span><br><span class="line">        <span class="keyword">if</span>(k&gt;=(<span class="number">1LL</span>&lt;&lt;cnt)) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// k太大</span></span><br><span class="line">        </span><br><span class="line">        ll res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;cnt; i++)</span><br><span class="line">            <span class="keyword">if</span>(k&amp;(<span class="number">1LL</span>&lt;&lt;i)) res^=p[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="合并两个线性基"><a href="#合并两个线性基" class="headerlink" title="合并两个线性基"></a>合并两个线性基</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LB <span class="title">merge</span><span class="params">(LB a, LB b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LB c=a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span>(b.d[i]) c.<span class="built_in">insert</span>(b.d[i]);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子：区间异或最大值"><a href="#例子：区间异或最大值" class="headerlink" title="例子：区间异或最大值"></a>例子：区间异或最大值</h3><p>给定数组 $a[1\ldots n]$，$q$ 次查询，每次询问 $[l,r]$ 中选若干个数异或的最大值。</p>
<p><strong>思路</strong>：对每个右端点 $r$ 维护一个线性基，查询时直接用对应线性基。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">ll a[N];</span><br><span class="line">LB lb[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lb[i]=lb[i<span class="number">-1</span>];</span><br><span class="line">        lb[i].<span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LB tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">62</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!lb[r].d[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 检查d[i]是否在[l,r]中</span></span><br><span class="line">        <span class="comment">// 这里简化处理，直接返回最大值</span></span><br><span class="line">        tmp.d[i]=lb[r].d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp.<span class="built_in">queryMax</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平面几何"><a href="#平面几何" class="headerlink" title="平面几何"></a>平面几何</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(x)&lt;eps) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x&lt;<span class="number">0</span>? <span class="number">-1</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x=<span class="number">0</span>, <span class="type">double</span> y=<span class="number">0</span>):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>+(<span class="type">const</span> Point &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x+p.x, y+p.y);&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="type">const</span> Point &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x-p.x, y-p.y);&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>*(<span class="type">double</span> k) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x*k, y*k);&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>/(<span class="type">double</span> k) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x/k, y/k);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x-p.x)&lt;<span class="number">0</span> || (<span class="built_in">sgn</span>(x-p.x)==<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(y-p.y)&lt;<span class="number">0</span>);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">sgn</span>(x-p.x)==<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(y-p.y)==<span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y);&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">len2</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x*x+y*y;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">unit</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> *<span class="keyword">this</span>/<span class="built_in">len</span>();&#125; <span class="comment">// 单位向量</span></span><br><span class="line">    <span class="function">Point <span class="title">rotate</span><span class="params">(<span class="type">double</span> ang)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x*<span class="built_in">cos</span>(ang)-y*<span class="built_in">sin</span>(ang), x*<span class="built_in">sin</span>(ang)+y*<span class="built_in">cos</span>(ang));&#125; <span class="comment">// 逆时针旋转</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point Vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> Vector &amp;a, <span class="type">const</span> Vector &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.x+a.y*b.y;&#125; <span class="comment">// 点积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(<span class="type">const</span> Vector &amp;a, <span class="type">const</span> Vector &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125; <span class="comment">// 叉积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">angle</span><span class="params">(<span class="type">const</span> Vector &amp;a, <span class="type">const</span> Vector &amp;b)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">acos</span>(<span class="built_in">dot</span>(a,b)/a.<span class="built_in">len</span>()/b.<span class="built_in">len</span>());&#125; <span class="comment">// 夹角</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span> </span>&#123;<span class="keyword">return</span> (a-b).<span class="built_in">len</span>();&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis2</span><span class="params">(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span> </span>&#123;<span class="keyword">return</span> (a-b).<span class="built_in">len2</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span></span><br><span class="line">&#123;</span><br><span class="line">    Point p, v; <span class="comment">// 点+方向向量</span></span><br><span class="line">    <span class="built_in">Line</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Line</span>(Point p, Vector v):<span class="built_in">p</span>(p), <span class="built_in">v</span>(v) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> t)</span> </span>&#123;<span class="keyword">return</span> p+v*t;&#125; <span class="comment">// 直线上的点</span></span><br><span class="line">    <span class="function">Line <span class="title">move</span><span class="params">(<span class="type">double</span> d)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Line</span>(p+v.<span class="built_in">rotate</span>(PI/<span class="number">2</span>).<span class="built_in">unit</span>()*d, v);&#125; <span class="comment">// 平移</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点在直线上的投影</span></span><br><span class="line"><span class="function">Point <span class="title">project</span><span class="params">(<span class="type">const</span> Line &amp;l, <span class="type">const</span> Point &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> l.p+l.v*(<span class="built_in">dot</span>(l.v, p-l.p)/l.v.<span class="built_in">len2</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点到直线距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis_to_line</span><span class="params">(<span class="type">const</span> Point &amp;p, <span class="type">const</span> Line &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">cross</span>(l.v, p-l.p))/l.v.<span class="built_in">len</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点到线段距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis_to_seg</span><span class="params">(<span class="type">const</span> Point &amp;p, <span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> <span class="built_in">dis</span>(p, a);</span><br><span class="line">    Vector v1=b-a, v2=p-a, v3=p-b;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(<span class="built_in">dot</span>(v1,v2))&lt;<span class="number">0</span>) <span class="keyword">return</span> v<span class="number">2.l</span>en();</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(<span class="built_in">dot</span>(v1,v3))&gt;<span class="number">0</span>) <span class="keyword">return</span> v<span class="number">3.l</span>en();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">cross</span>(v1,v2))/v<span class="number">1.l</span>en();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两直线交点</span></span><br><span class="line"><span class="function">Point <span class="title">line_intersection</span><span class="params">(<span class="type">const</span> Line &amp;a, <span class="type">const</span> Line &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector u=a.p-b.p;</span><br><span class="line">    <span class="type">double</span> t=<span class="built_in">cross</span>(b.v, u)/<span class="built_in">cross</span>(a.v, b.v);</span><br><span class="line">    <span class="keyword">return</span> a.p+a.v*t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多边形面积（有向面积）</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">polygon_area</span><span class="params">(vector&lt;Point&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> area=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n=p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        area+=<span class="built_in">cross</span>(p[i], p[(i<span class="number">+1</span>)%n]);</span><br><span class="line">    <span class="keyword">return</span> area/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点在多边形内（射线法）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">point_in_polygon</span><span class="params">(<span class="type">const</span> Point &amp;p, vector&lt;Point&gt; &amp;poly)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=poly.<span class="built_in">size</span>(), cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Point a=poly[i], b=poly[(i<span class="number">+1</span>)%n];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">sgn</span>(<span class="built_in">cross</span>(a-p, b-p))==<span class="number">0</span> &amp;&amp; <span class="built_in">sgn</span>(<span class="built_in">dot</span>(a-p, b-p))&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 在边上</span></span><br><span class="line">        <span class="type">int</span> k=<span class="built_in">sgn</span>(<span class="built_in">cross</span>(b-a, p-a));</span><br><span class="line">        <span class="type">int</span> u=<span class="built_in">sgn</span>(a.y-p.y), v=<span class="built_in">sgn</span>(b.y-p.y);</span><br><span class="line">        <span class="keyword">if</span>(k&gt;<span class="number">0</span> &amp;&amp; u&lt;<span class="number">0</span> &amp;&amp; v&gt;=<span class="number">0</span>) cnt++;</span><br><span class="line">        <span class="keyword">if</span>(k&lt;<span class="number">0</span> &amp;&amp; v&lt;<span class="number">0</span> &amp;&amp; u&gt;=<span class="number">0</span>) cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt!=<span class="number">0</span>; <span class="comment">// 0:外部, 1:内部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line">    Point c;</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line">    <span class="built_in">Circle</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Circle</span>(Point c, <span class="type">double</span> r):<span class="built_in">c</span>(c), <span class="built_in">r</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function">Point <span class="title">point</span><span class="params">(<span class="type">double</span> a)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">Point</span>(c.x+<span class="built_in">cos</span>(a)*r, c.y+<span class="built_in">sin</span>(a)*r);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两圆交点</span></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">circle_intersection</span><span class="params">(Circle c1, Circle c2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;Point&gt; res;</span><br><span class="line">    <span class="type">double</span> d=<span class="built_in">dis</span>(c<span class="number">1.</span>c, c<span class="number">2.</span>c);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(d)==<span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 重合</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(d-c<span class="number">1.</span>r-c<span class="number">2.</span>r)&gt;<span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 相离</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">sgn</span>(d-<span class="built_in">fabs</span>(c<span class="number">1.</span>r-c<span class="number">2.</span>r))&lt;<span class="number">0</span>) <span class="keyword">return</span> res; <span class="comment">// 内含</span></span><br><span class="line">    <span class="type">double</span> a=<span class="built_in">angle</span>(c<span class="number">2.</span>c-c<span class="number">1.</span>c, <span class="built_in">Point</span>(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="type">double</span> da=<span class="built_in">acos</span>((c<span class="number">1.</span>r*c<span class="number">1.</span>r+d*d-c<span class="number">2.</span>r*c<span class="number">2.</span>r)/(<span class="number">2</span>*c<span class="number">1.</span>r*d));</span><br><span class="line">    Point p1=c<span class="number">1.</span><span class="built_in">point</span>(a-da), p2=c<span class="number">1.</span><span class="built_in">point</span>(a+da);</span><br><span class="line">    res.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    <span class="keyword">if</span>(p1==p2) <span class="keyword">return</span> res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="立体几何"><a href="#立体几何" class="headerlink" title="立体几何"></a>立体几何</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point3</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y, z;</span><br><span class="line">    <span class="built_in">Point3</span>(<span class="type">double</span> x=<span class="number">0</span>, <span class="type">double</span> y=<span class="number">0</span>, <span class="type">double</span> z=<span class="number">0</span>):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y), <span class="built_in">z</span>(z) &#123;&#125;</span><br><span class="line">    Point3 <span class="keyword">operator</span>+(<span class="type">const</span> Point3 &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point3</span>(x+p.x, y+p.y, z+p.z);&#125;</span><br><span class="line">    Point3 <span class="keyword">operator</span>-(<span class="type">const</span> Point3 &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point3</span>(x-p.x, y-p.y, z-p.z);&#125;</span><br><span class="line">    Point3 <span class="keyword">operator</span>*(<span class="type">double</span> k) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point3</span>(x*k, y*k, z*k);&#125;</span><br><span class="line">    Point3 <span class="keyword">operator</span>/(<span class="type">double</span> k) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point3</span>(x/k, y/k, z/k);&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">len</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(x*x+y*y+z*z);&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">len2</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> x*x+y*y+z*z;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Point3 Vector3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> Vector3 &amp;a, <span class="type">const</span> Vector3 &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.x+a.y*b.y+a.z*b.z;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Vector3 <span class="title">cross</span><span class="params">(<span class="type">const</span> Vector3 &amp;a, <span class="type">const</span> Vector3 &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector3</span>(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(<span class="type">const</span> Point3 &amp;a, <span class="type">const</span> Point3 &amp;b)</span> </span>&#123;<span class="keyword">return</span> (a-b).<span class="built_in">len</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平面（用法向量表示）</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Plane</span></span><br><span class="line">&#123;</span><br><span class="line">    Point3 p, n; <span class="comment">// 点+法向量</span></span><br><span class="line">    <span class="built_in">Plane</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Plane</span>(Point3 p, Vector3 n):<span class="built_in">p</span>(p), <span class="built_in">n</span>(n) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点到平面距离</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis2plane</span><span class="params">(<span class="type">const</span> Point3 &amp;p, <span class="type">const</span> Plane &amp;pl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">dot</span>(p-pl.p, pl.n))/pl.n.<span class="built_in">len</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直线与平面交点</span></span><br><span class="line"><span class="function">Point3 <span class="title">lp_inter</span><span class="params">(Point3 p, Vector3 v, Plane pl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> t=<span class="built_in">dot</span>(pl.n, pl.p-p)/<span class="built_in">dot</span>(pl.n, v);</span><br><span class="line">    <span class="keyword">return</span> p+v*t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 四面体体积</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">tet_vol</span><span class="params">(Point3 a, Point3 b, Point3 c, Point3 d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(<span class="built_in">dot</span>(<span class="built_in">cross</span>(b-a, c-a), d-a))/<span class="number">6.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="凸包算法"><a href="#凸包算法" class="headerlink" title="凸包算法"></a>凸包算法</h2><p>解决二维平面上的点集凸包问题，即求出包含所有点的最小凸多边形</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x=<span class="number">0</span>, <span class="type">double</span> y=<span class="number">0</span>):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line">    Point <span class="keyword">operator</span>-(<span class="type">const</span> Point &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> <span class="built_in">Point</span>(x-p.x, y-p.y);&#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point &amp;p) <span class="type">const</span> &#123;<span class="keyword">return</span> x&lt;p.x || (x==p.x &amp;&amp; y&lt;p.y);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cross</span><span class="params">(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.x*b.y-a.y*b.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两点距离平方</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">disSq</span><span class="params">(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> dx=a.x-b.x, dy=a.y-b.y;</span><br><span class="line">    <span class="keyword">return</span> dx*dx+dy*dy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point pivot; <span class="comment">// 凸包基点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Point &amp;a, <span class="type">const</span> Point &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> c=<span class="built_in">cross</span>(a-pivot, b-pivot);</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">disSq</span>(a, pivot)&lt;<span class="built_in">disSq</span>(b, pivot);</span><br><span class="line">    <span class="keyword">return</span> c&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;Point&gt; <span class="title">convexHull</span><span class="params">(vector&lt;Point&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=p.<span class="built_in">size</span>(), k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="type">int</span> minn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) <span class="keyword">if</span>(p[i]&lt;p[minn]) minn=i;</span><br><span class="line">    <span class="built_in">swap</span>(p[<span class="number">0</span>], p[minn]);</span><br><span class="line">    pivot=p[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">sort</span>(p.<span class="built_in">begin</span>()<span class="number">+1</span>, p.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    stack&lt;Point&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(p[<span class="number">0</span>]), s.<span class="built_in">push</span>(p[<span class="number">1</span>]), s.<span class="built_in">push</span>(p[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Point top=s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cross</span>(top-s.<span class="built_in">top</span>(), p[i]-s.<span class="built_in">top</span>())&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top=s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">push</span>(top); s.<span class="built_in">push</span>(p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;Point&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><p>生成函数是组合计数的强大工具，将数列 ${a_n}$ 编码为幂级数</p>
<h3 id="普通生成函数（OGF）"><a href="#普通生成函数（OGF）" class="headerlink" title="普通生成函数（OGF）"></a>普通生成函数（OGF）</h3><script type="math/tex; mode=display">
F(x)=\sum_{n=0}^{\infty}a_nx^n=a_0+a_1x+a_2x^2+\cdots</script><p><strong>常用公式</strong>：</p>
<ul>
<li>$\frac{1}{1-x}=1+x+x^2+\cdots=\sum_{n=0}^{\infty}x^n$</li>
<li>$\frac{1}{1-ax}=\sum_{n=0}^{\infty}a^nx^n$</li>
<li>$\frac{1}{(1-x)^2}=\sum_{n=0}^{\infty}(n+1)x^n$</li>
<li>$\frac{1}{(1-x)^k}=\sum<em>{n=0}^{\infty}C</em>{n+k-1}^{k-1}x^n$</li>
<li>$(1+x)^n=\sum_{k=0}^{n}C_n^kx^k$（二项式定理）</li>
<li>$\frac{1}{1-x-x^2}=\sum_{n=0}^{\infty}F_nx^n$（Fibonacci数）</li>
</ul>
<p><strong>运算</strong>：</p>
<ul>
<li>加法：$(F+G)(x)=\sum_{n=0}^{\infty}(a_n+b_n)x^n$</li>
<li>数乘：$(cF)(x)=\sum_{n=0}^{\infty}ca_nx^n$</li>
<li>卷积：$(F\cdot G)(x)=\sum<em>{n=0}^{\infty}\left(\sum</em>{k=0}^{n}a<em>kb</em>{n-k}\right)x^n$</li>
<li>平移：$x^mF(x)=\sum_{n=0}^{\infty}a_nx^{n+m}$</li>
<li>求导：$F’(x)=\sum_{n=1}^{\infty}na_nx^{n-1}$</li>
</ul>
<h3 id="指数生成函数（EGF）"><a href="#指数生成函数（EGF）" class="headerlink" title="指数生成函数（EGF）"></a>指数生成函数（EGF）</h3><script type="math/tex; mode=display">
F(x)=\sum_{n=0}^{\infty}\frac{a_n}{n!}x^n=a_0+\frac{a_1}{1!}x+\frac{a_2}{2!}x^2+\cdots</script><p><strong>常用公式</strong>：</p>
<ul>
<li>$e^x=\sum_{n=0}^{\infty}\frac{x^n}{n!}$</li>
<li>$e^{ax}=\sum_{n=0}^{\infty}\frac{a^n}{n!}x^n$</li>
<li>$\ln(1+x)=\sum_{n=1}^{\infty}\frac{(-1)^{n+1}}{n}x^n$</li>
<li>$\sin x=\sum_{n=0}^{\infty}\frac{(-1)^n}{(2n+1)!}x^{2n+1}$</li>
<li>$\cos x=\sum_{n=0}^{\infty}\frac{(-1)^n}{(2n)!}x^{2n}$</li>
</ul>
<p><strong>卷积</strong>：$(F\cdot G)(x)=\sum<em>{n=0}^{\infty}\frac{1}{n!}\left(\sum</em>{k=0}^{n}C<em>n^ka_kb</em>{n-k}\right)x^n$</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p><strong>1. 整数拆分</strong>：将 $n$ 拆分成若干正整数的方案数</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{\infty}\frac{1}{1-x^i}</script><p><strong>2. 组合选取</strong>：从 $n$ 种物品中选取，每种可选 $0$ 到 $m_i$ 个</p>
<script type="math/tex; mode=display">
\prod_{i=1}^{n}(1+x+x^2+\cdots+x^{m_i})=\prod_{i=1}^{n}\frac{1-x^{m_i+1}}{1-x}</script><p><strong>3. 错排问题</strong>：$n$ 个元素的错排数 $D_n$</p>
<script type="math/tex; mode=display">
D_n=n!\sum_{k=0}^{n}\frac{(-1)^k}{k!}</script><p>生成函数：$\frac{e^{-x}}{1-x}$</p>
<p><strong>4. 第二类斯特林数</strong> $S(n,k)$：将 $n$ 个不同元素分成 $k$ 个非空集合</p>
<script type="math/tex; mode=display">
x^n=\sum_{k=0}^{n}S(n,k)x^{\underline{k}}</script><p>其中 $x^{\underline{k}}=x(x-1)(x-2)\cdots(x-k+1)$（下降阶乘幂）</p>
<h3 id="代码（多项式运算）"><a href="#代码（多项式运算）" class="headerlink" title="代码（多项式运算）"></a>代码（多项式运算）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> vector&lt;ll&gt; poly;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多项式加法</span></span><br><span class="line"><span class="function">poly <span class="title">add</span><span class="params">(poly a, poly b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">    <span class="function">poly <span class="title">c</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); i++) c[i]+=a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;b.<span class="built_in">size</span>(); i++) c[i]+=b[i];</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多项式乘法O(n^2)</span></span><br><span class="line"><span class="function">poly <span class="title">mul</span><span class="params">(poly a, poly b, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>(), m=b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">poly <span class="title">c</span><span class="params">(n+m<span class="number">-1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span><br><span class="line">            c[i+j]=(c[i+j]+a[i]*b[j])%mod;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂（生成函数）</span></span><br><span class="line"><span class="function">poly <span class="title">qpow</span><span class="params">(poly a, ll n, ll mod, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">    res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=<span class="built_in">mul</span>(res, a, mod);</span><br><span class="line">        a=<span class="built_in">mul</span>(a, a, mod);</span><br><span class="line">        res.<span class="built_in">resize</span>(len);</span><br><span class="line">        a.<span class="built_in">resize</span>(len);</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 1/(1-x) 的前 n 项</span></span><br><span class="line"><span class="function">poly <span class="title">inv_1_sub_x</span><span class="params">(<span class="type">int</span> n, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) res[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二项式定理</span></span><br><span class="line"><span class="function">poly <span class="title">binomial</span><span class="params">(ll n, <span class="type">int</span> len, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">poly <span class="title">res</span><span class="params">(len)</span></span>;</span><br><span class="line">    res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)</span><br><span class="line">        res[i]=res[i<span class="number">-1</span>]*(n-i<span class="number">+1</span>)%mod*<span class="built_in">qpow</span>(i, mod<span class="number">-2</span>, mod)%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h2><p>用于多项式乘法 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> complex&lt;<span class="type">double</span>&gt; cd;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FFT</span><span class="params">(vector&lt;cd&gt;&amp; a, <span class="type">bool</span> invert)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> bit=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j&amp;bit; bit&gt;&gt;=<span class="number">1</span>) j^=bit;</span><br><span class="line">        j^=bit;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>; len&lt;=n; len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> ang=<span class="number">2</span>*PI/len*(invert?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">        <span class="function">cd <span class="title">wlen</span><span class="params">(cos(ang), sin(ang))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">cd <span class="title">w</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;len/<span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cd u=a[i+j], v=w*a[i+j+len/<span class="number">2</span>];</span><br><span class="line">                a[i+j]=u+v;</span><br><span class="line">                a[i+j+len/<span class="number">2</span>]=u-v;</span><br><span class="line">                w*=wlen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(invert)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(cd &amp;x: a) x/=n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多项式乘法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multi</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;cd&gt; <span class="title">fa</span><span class="params">(a.begin(), a.end())</span>, <span class="title">fb</span><span class="params">(b.begin(), b.end())</span></span>;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&lt;a.<span class="built_in">size</span>()+b.<span class="built_in">size</span>()) n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    fa.<span class="built_in">resize</span>(n), fb.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="built_in">FFT</span>(fa, <span class="literal">false</span>), <span class="built_in">FFT</span>(fb, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) fa[i]*=fb[i];</span><br><span class="line">    <span class="built_in">FFT</span>(fa, <span class="literal">true</span>);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) res[i]=<span class="built_in">round</span>(fa[i].<span class="built_in">real</span>());</span><br><span class="line">    <span class="comment">// 如果是大数乘法，需要处理进位</span></span><br><span class="line">    <span class="comment">// int carry=0;</span></span><br><span class="line">    <span class="comment">// for(int i=0; i&lt;n; i++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     res[i]+=carry;</span></span><br><span class="line">    <span class="comment">//     carry=res[i]/10;</span></span><br><span class="line">    <span class="comment">//     res[i]%=10;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数论变换（NTT）"><a href="#数论变换（NTT）" class="headerlink" title="数论变换（NTT）"></a>数论变换（NTT）</h2><p>对于需要在模意义下计算的情况，则需要NTT</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ROOT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll b, ll exp, ll mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll res=<span class="number">1</span>;</span><br><span class="line">    b%=mod;</span><br><span class="line">    <span class="keyword">while</span>(exp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(exp&amp;<span class="number">1</span>)</span><br><span class="line">            res=(res*b)%mod;</span><br><span class="line">        b=(b*b)%mod;</span><br><span class="line">        exp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">NTT</span><span class="params">(vector&lt;ll&gt;&amp; a, <span class="type">bool</span> invert)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> bit=n&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j&amp;bit; bit&gt;&gt;=<span class="number">1</span>) j^=bit;</span><br><span class="line">        j^=bit;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j) <span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>; len&lt;=n; len&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> wlen=<span class="built_in">qpow</span>(ROOT, (MOD<span class="number">-1</span>)/len, MOD);</span><br><span class="line">        <span class="keyword">if</span>(invert) wlen=<span class="built_in">qpow</span>(wlen, MOD<span class="number">-2</span>, MOD);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i+=len)</span><br><span class="line">        &#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;len/<span class="number">2</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> u=a[i+j], v=w*a[i+j+len/<span class="number">2</span>]%MOD;</span><br><span class="line">                a[i+j]=(u+v)%MOD;</span><br><span class="line">                a[i+j+len/<span class="number">2</span>]=(u-v+MOD)%MOD;</span><br><span class="line">                w=(<span class="number">1LL</span>*w*wlen)%MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(invert)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> nInv=<span class="built_in">qpow</span>(n, MOD<span class="number">-2</span>, MOD);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> &amp;x: a) x=(<span class="number">1LL</span>*x*nInv)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>用于处理有向无环图（DAG）的排序问题，如：比赛排名、任务调度等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topoSort</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; &amp;G)</span><span class="comment">//G为邻接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; topo;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in</span><span class="params">(G.size(), <span class="number">0</span>)</span></span>; <span class="comment">//记录每个节点的入度</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;  <span class="comment">// 也可以使用priority_queue</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>; u&lt;G.<span class="built_in">size</span>(); u++)<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: G[u])in[v]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">0</span>; u&lt;G.<span class="built_in">size</span>(); u++)<span class="keyword">if</span>(in[u]==<span class="number">0</span>)s.<span class="built_in">push</span>(u);</span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> u=s.<span class="built_in">top</span>(); s.<span class="built_in">pop</span>();</span><br><span class="line">      topo.<span class="built_in">push_back</span>(u);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;v: G[u])</span><br><span class="line">      &#123;</span><br><span class="line">        in[v]--;</span><br><span class="line">        <span class="keyword">if</span>(in[v]==<span class="number">0</span>)s.<span class="built_in">push</span>(v);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>用于求解单源最短路距离问题（非负权图），时间复杂度 $O(n\log n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int, int&gt;</span> <span class="comment">// (dist, vertex) 方便使用优先队列排序</span></span></span><br><span class="line"><span class="type">const</span> ll INF=LLONG_MAX;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;ll&gt; <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> vector&lt;vector&lt;pii&gt; &gt; &amp;G, <span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n=G.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">dist</span><span class="params">(n, INF)</span></span>;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; pq;</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d, u]=pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(d&gt;dist[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: G[u])<span class="keyword">if</span>(dist[u]+w&lt;dist[v])</span><br><span class="line">        &#123;</span><br><span class="line">            dist[v]=dist[u]+w;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;dist[v], v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p>适用于可能包含负权边的有向图或无向图的最短路问题，时间复杂度 $O(nm)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="type">const</span> ll INF=LLONG_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> _u, <span class="type">int</span> _v, <span class="type">int</span> _w): <span class="built_in">u</span>(_u), <span class="built_in">v</span>(_v), <span class="built_in">w</span>(_w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param s: 源点</span></span><br><span class="line"><span class="comment">* @param end: 终点</span></span><br><span class="line"><span class="comment">* @param E: 边集</span></span><br><span class="line"><span class="comment">* @param n: 点数</span></span><br><span class="line"><span class="comment">* @param dist: 最短路距离</span></span><br><span class="line"><span class="comment">* @param path: 最短路径</span></span><br><span class="line"><span class="comment">* @return: 是否存在负环</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(ll s, ll end, <span class="type">const</span> vector&lt;Edge&gt; &amp;E, ll n , vector&lt;ll&gt; &amp;dist, vector&lt;ll&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dist.<span class="built_in">assign</span>(n, INF);</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;e: E)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[e.u]!=INF &amp;&amp; dist[e.u]+e.w&lt;dist[e.v])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[e.v]=dist[e.u]+e.w;</span><br><span class="line">                pre[e.v]=e.u;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否存在负环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;e: E)</span><br><span class="line">        <span class="keyword">if</span>(dist[e.u]!=INF &amp;&amp; dist[e.u]+e.w&lt;dist[e.v]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(dist[end]==INF) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在最短路</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求最短路径</span></span><br><span class="line">    path.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=end; i!=<span class="number">-1</span>; i=pre[i]) path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h3><p>该算法是Bellman-Ford算法的优化版本，时间复杂度 $O(km)$，其中 $k$ 是常数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="type">const</span> ll INF=LLONG_MAX;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, w;</span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> _to, <span class="type">int</span> _w): <span class="built_in">to</span>(_to), <span class="built_in">w</span>(_w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(ll s, ll end, ll n, <span class="type">const</span> vector&lt;vector&lt;Edge&gt; &gt; &amp;G, vector&lt;ll&gt; &amp;dist, vector&lt;ll&gt; &amp;path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">pre</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inq</span><span class="params">(n, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    dist.<span class="built_in">assign</span>(n, INF);</span><br><span class="line">    dist[s]=<span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    inq[s]=<span class="literal">true</span>, cnt[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> [v, w]: G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[u]!=INF &amp;&amp; dist[u]+w&lt;dist[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v]=dist[u]+w;</span><br><span class="line">                pre[v]=u;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    inq[v]=<span class="literal">true</span>, cnt[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[v]&gt;n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[end]==INF) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在最短路</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求最短路径</span></span><br><span class="line">    path.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll i=end; i!=<span class="number">-1</span>; i=pre[i]) path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd-Warshall-算法"><a href="#Floyd-Warshall-算法" class="headerlink" title="Floyd-Warshall 算法"></a>Floyd-Warshall 算法</h3><p>用于求解所有顶点对之间的最短路径，适用于有向图或无向图，可以处理负权边（但不能有负权回路）。 时间复杂度 $O(n^3)$ ， 仅适用于 $n \le 500$ 的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, dis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="keyword">if</span>(dis[i][k]!=INF &amp;&amp; dis[k][j]!=INF)</span><br><span class="line">                dis[i][j]=<span class="built_in">min</span>(dis[i][j], dis[i][k]+dis[k][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) dis[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dis[i][j]=INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检测负权回路</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasNegativeCycle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">        <span class="keyword">if</span>(dis[k][k]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要重建最短路径，可以额外维护一个<code>next</code>矩阵，记录从<code>i</code>到<code>j</code>的最短路径上<code>i</code>的后继节点。</p>
</blockquote>
<h2 id="最小生成树（MST）"><a href="#最小生成树（MST）" class="headerlink" title="最小生成树（MST）"></a>最小生成树（MST）</h2><h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p>时间复杂度 $O(m\log m)$，常用于稀疏图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;e) <span class="type">const</span> &#123;<span class="keyword">return</span> w&lt;e.w;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x]==x? x: fa[x]=<span class="built_in">find</span>(fa[x]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">kruskal</span><span class="params">(vector&lt;Edge&gt; &amp;edges, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) fa[i]=i;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [u, v, w]: edges)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fu=<span class="built_in">find</span>(u), fv=<span class="built_in">find</span>(v);</span><br><span class="line">        <span class="keyword">if</span>(fu!=fv)</span><br><span class="line">        &#123;</span><br><span class="line">            fa[fu]=fv;</span><br><span class="line">            sum+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==n<span class="number">-1</span>? sum: <span class="number">-1</span>; <span class="comment">// -1表示图不连通</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>时间复杂度 $O(m\log n)$，常用于稠密图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">prim</span><span class="params">(vector&lt;vector&lt;pii&gt;&gt; &amp;g, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n<span class="number">+1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    pq.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// &#123;权重, 节点&#125;</span></span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [w, u]=pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        sum+=w;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, wt]: g[u])</span><br><span class="line">            <span class="keyword">if</span>(!vis[v]) pq.<span class="built_in">push</span>(&#123;wt, v&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt==n? sum: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强连通分量-SCC"><a href="#强连通分量-SCC" class="headerlink" title="强连通分量(SCC)"></a>强连通分量(SCC)</h2><h3 id="Kosaraju算法"><a href="#Kosaraju算法" class="headerlink" title="Kosaraju算法"></a>Kosaraju算法</h3><p>时间复杂度 $O(V+E)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN], G_[MAXN], comp_nodes[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; order, <span class="built_in">comp</span>(MAXN);</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> scc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v: G[u]) <span class="keyword">if</span>(!vis[v]) <span class="built_in">dfs1</span>(v);</span><br><span class="line">    order.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    comp[u]=c;</span><br><span class="line">    comp_nodes[c].<span class="built_in">push_back</span>(u);</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v: G_[u]) <span class="keyword">if</span>(!vis[v]) <span class="built_in">dfs2</span>(v, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kosaraju</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    order.<span class="built_in">clear</span>();</span><br><span class="line">    scc=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(comp, <span class="number">-1</span>, <span class="built_in">sizeof</span>(comp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(!vis[i]) <span class="built_in">dfs1</span>(i);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)order.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) <span class="keyword">if</span>(!vis[order[i]]) </span><br><span class="line">        <span class="built_in">dfs2</span>(order[i], ++scc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; DAG[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildDAG</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>; u&lt;=n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> v: G[u])<span class="keyword">if</span>(comp[u]!=comp[v]) </span><br><span class="line">            DAG[comp[u]].<span class="built_in">push_back</span>(comp[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去重边（可选）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=scc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(DAG[i].<span class="built_in">begin</span>(), DAG[i].<span class="built_in">end</span>());</span><br><span class="line">        DAG[i].<span class="built_in">erase</span>(<span class="built_in">unique</span>(DAG[i].<span class="built_in">begin</span>(), DAG[i].<span class="built_in">end</span>()), DAG[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h3><p>不仅可用于求强连通分量，还可用于求割点、桥等图论问题。时间复杂度 $O(V+E)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], comp[N], inSt[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> dfsti=<span class="number">0</span>, scc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* @param u 当前节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dfsti;</span><br><span class="line">    st.<span class="built_in">push</span>(u); inSt[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(v);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(inSt[v]) low[u]=<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            inSt[x]=<span class="number">0</span>, comp[x]=scc;</span><br><span class="line">            <span class="keyword">if</span>(x==u) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用方法：</span></span><br><span class="line"><span class="comment">for(int i=1; i&lt;=n; i++) if(!dfn[i]) tarjan(i); // 遍历所有节点求解强连通分量</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="欧拉回路-欧拉路径"><a href="#欧拉回路-欧拉路径" class="headerlink" title="欧拉回路/欧拉路径"></a>欧拉回路/欧拉路径</h2><p><strong>欧拉回路</strong>：经过图中每条边恰好一次的回路。<strong>欧拉路径</strong>：经过图中每条边恰好一次的路径。</p>
<ul>
<li><strong>无向图欧拉回路</strong>：连通且所有点度数为偶数</li>
<li><strong>无向图欧拉路径</strong>：连通且恰有0或2个奇度数点</li>
<li><strong>有向图欧拉回路</strong>：强连通且所有点入度=出度</li>
<li><strong>有向图欧拉路径</strong>：弱连通且恰有一个点出度-入度=1，一个点入度-出度=1，其余点入度=出度</li>
</ul>
<h3 id="Hierholzer算法（无向图）"><a href="#Hierholzer算法（无向图）" class="headerlink" title="Hierholzer算法（无向图）"></a>Hierholzer算法（无向图）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pii&gt; g[N]; <span class="comment">// &#123;邻接点, 边编号&#125;</span></span><br><span class="line"><span class="type">bool</span> vis[M]; <span class="comment">// 边是否被访问</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, id]: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[id]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[id]=<span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从起点st开始找欧拉路径</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(st);</span><br><span class="line">    <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hierholzer算法（有向图）"><a href="#Hierholzer算法（有向图）" class="headerlink" title="Hierholzer算法（有向图）"></a>Hierholzer算法（有向图）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> cur[N]; <span class="comment">// 当前弧优化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u]; i&lt;g[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=g[u][i];</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">euler</span><span class="params">(<span class="type">int</span> st)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(st);</span><br><span class="line">    <span class="built_in">reverse</span>(path.<span class="built_in">begin</span>(), path.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2-SAT"></a>2-SAT</h2><p>给定 $n$ 个布尔变量和 $m$ 个形如”$x_i$ 为真或 $x_j$ 为假”的约束，判断是否有解。</p>
<p>对每个变量 $x_i$ 建立两个点 $i$(真) 和 $i’$(假)。约束”$x_i$ 或 $x_j$”转化为：$\neg x_i\Rightarrow x_j$ 和 $\neg x_j\Rightarrow x_i$。在图上跑强连通分量，若 $x_i$ 和 $x_i’$ 在同一SCC则无解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> n; <span class="comment">// n个变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// i表示xi为真，i+n表示xi为假</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addClause</span><span class="params">(<span class="type">int</span> a, <span class="type">bool</span> va, <span class="type">int</span> b, <span class="type">bool</span> vb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// (a,va) OR (b,vb)</span></span><br><span class="line">    <span class="comment">// !a =&gt; b, !b =&gt; a</span></span><br><span class="line">    g[a+(va?<span class="number">0</span>:n)].<span class="built_in">push_back</span>(b+(vb?n:<span class="number">0</span>));</span><br><span class="line">    g[b+(vb?<span class="number">0</span>:n)].<span class="built_in">push_back</span>(a+(va?n:<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tarjan求SCC</span></span><br><span class="line"><span class="type">int</span> dfn[N], low[N], comp[N], inSt[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> dfscnt=<span class="number">0</span>, scc=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dfscnt;</span><br><span class="line">    st.<span class="built_in">push</span>(u); inSt[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) <span class="built_in">tarjan</span>(v), low[u]=<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(inSt[v]) low[u]=<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            inSt[x]=<span class="number">0</span>; comp[x]=scc;</span><br><span class="line">            <span class="keyword">if</span>(x==u) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n; i++)</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(comp[i]==comp[i+n]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用例子：</span></span><br><span class="line"><span class="comment">addClause(0, true, 1, false); // x0 OR !x1</span></span><br><span class="line"><span class="comment">addClause(1, true, 2, true);  // x1 OR x2</span></span><br><span class="line"><span class="comment">if(solve()) cout&lt;&lt;&quot;YES\n&quot;;</span></span><br><span class="line"><span class="comment">else cout&lt;&lt;&quot;NO\n&quot;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 输出方案：comp[i] &gt; comp[i+n] 则 xi=true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="差分约束"><a href="#差分约束" class="headerlink" title="差分约束"></a>差分约束</h2><p>求解一组形如 $x_i-x_j\le c_k$ 的不等式组，判断是否有解。</p>
<p><strong>思路</strong>：将不等式转化为图，$x_i-x_j\le c$ 建边 $j\to i$ 权值 $c$。求最短路，若存在负环则无解，否则 $d[i]$ 即为一组解。</p>
<h3 id="求最大值（用最短路）"><a href="#求最大值（用最短路）" class="headerlink" title="求最大值（用最短路）"></a>求最大值（用最短路）</h3><p>$x_i-x_j\le c$ 建边 $j\to i$ 权值 $c$，求最短路。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5005</span>;</span><br><span class="line"><span class="type">const</span> ll INF=LLONG_MAX;</span><br><span class="line">vector&lt;pii&gt; g[N]; <span class="comment">// &#123;v, w&#125;</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> st, vector&lt;ll&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span>, <span class="title">inq</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">assign</span>(n<span class="number">+1</span>, INF);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 超级源点，连接所有点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        d[i]=<span class="number">0</span>;</span><br><span class="line">        inq[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                d[v]=d[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    inq[v]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(++cnt[v]&gt;n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">// xi - xj &lt;= c</span></span><br><span class="line"><span class="comment">g[j].push_back(&#123;i, c&#125;);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">vector&lt;ll&gt; d;</span></span><br><span class="line"><span class="comment">if(spfa(1, d)) cout&lt;&lt;&quot;有解\n&quot;;</span></span><br><span class="line"><span class="comment">else cout&lt;&lt;&quot;无解\n&quot;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="求最小值（用最长路）"><a href="#求最小值（用最长路）" class="headerlink" title="求最小值（用最长路）"></a>求最小值（用最长路）</h3><p>$x_i-x_j\ge c$ 转化为 $x_j-x_i\le -c$，建边 $i\to j$ 权值 $-c$，求最长路。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa_max</span><span class="params">(<span class="type">int</span> st, vector&lt;ll&gt; &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span>, <span class="title">inq</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    d.<span class="built_in">assign</span>(n<span class="number">+1</span>, -INF);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        d[i]=<span class="number">0</span>;</span><br><span class="line">        inq[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&lt;d[u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                d[v]=d[u]+w;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    inq[v]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(++cnt[v]&gt;n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有向图缩点"><a href="#有向图缩点" class="headerlink" title="有向图缩点"></a>有向图缩点</h2><p>将有向图的每个强连通分量缩成一个点，得到DAG（有向无环图）。</p>
<p>用Tarjan或Kosaraju求强连通分量，然后重新建图。缩点后常用于DP。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N], dag[N];</span><br><span class="line"><span class="type">int</span> n, m, scc_cnt;</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], comp[N], inSt[N];</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="type">int</span> dfscnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dfscnt;</span><br><span class="line">    st.<span class="built_in">push</span>(u); inSt[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v]) <span class="built_in">tarjan</span>(v), low[u]=<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(inSt[v]) low[u]=<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])</span><br><span class="line">    &#123;</span><br><span class="line">        scc_cnt++;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x=st.<span class="built_in">top</span>(); st.<span class="built_in">pop</span>();</span><br><span class="line">            inSt[x]=<span class="number">0</span>; comp[x]=scc_cnt;</span><br><span class="line">            <span class="keyword">if</span>(x==u) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rebuild</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>; u&lt;=n; u++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v: g[u])</span><br><span class="line">            <span class="keyword">if</span>(comp[u]!=comp[v])</span><br><span class="line">                dag[comp[u]].<span class="built_in">push_back</span>(comp[v]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=scc_cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(dag[i].<span class="built_in">begin</span>(), dag[i].<span class="built_in">end</span>());</span><br><span class="line">        dag[i].<span class="built_in">erase</span>(<span class="built_in">unique</span>(dag[i].<span class="built_in">begin</span>(), dag[i].<span class="built_in">end</span>()), dag[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">for(int i=1; i&lt;=n; i++)</span></span><br><span class="line"><span class="comment">    if(!dfn[i]) tarjan(i);</span></span><br><span class="line"><span class="comment">rebuild();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 缩点后DP示例：求DAG最长路</span></span><br><span class="line"><span class="comment">int dp[N];</span></span><br><span class="line"><span class="comment">int dfs_dag(int u)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if(dp[u]) return dp[u];</span></span><br><span class="line"><span class="comment">    dp[u]=1;</span></span><br><span class="line"><span class="comment">    for(int v: dag[u])</span></span><br><span class="line"><span class="comment">        dp[u]=max(dp[u], dfs_dag(v)+1);</span></span><br><span class="line"><span class="comment">    return dp[u];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><h3 id="Kuhn-Munkres算法"><a href="#Kuhn-Munkres算法" class="headerlink" title="Kuhn-Munkres算法"></a>Kuhn-Munkres算法</h3><p>匈牙利算法用于求解二分图的最大匹配问题，时间复杂度 $O(nm)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">505</span>;</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 左右节点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; match; <span class="comment">// match[v] 为与右部 v 匹配的左部点</span></span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: G[u])<span class="keyword">if</span>(!vis[v])</span><br><span class="line">    &#123;</span><br><span class="line">        vis[v]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(match[v]==<span class="number">-1</span> || <span class="built_in">dfs</span>(match[v]))</span><br><span class="line">        &#123;</span><br><span class="line">            match[v]=u;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kuhn</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    match.<span class="built_in">assign</span>(m<span class="number">+1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis.<span class="built_in">assign</span>(m<span class="number">+1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Hopcroft-Karp算法"><a href="#Hopcroft-Karp算法" class="headerlink" title="Hopcroft-Karp算法"></a>Hopcroft-Karp算法</h3><p>用于求解大数据集下的二分图最大匹配问题，时间复杂度 $O(m\sqrt{n})$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">505</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> matchL[MAXN], matchR[MAXN], dist[MAXN];</span><br><span class="line"><span class="type">int</span> n,m; <span class="comment">// 左右节点数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>; u&lt;=n; u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(matchL[u]==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[u]=<span class="number">0</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> dist[u]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> f=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v: G[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matchR[v]==<span class="number">-1</span>) f=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[matchR[v]]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[matchR[v]]=dist[u]<span class="number">+1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(matchR[v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: G[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(matchR[v]==<span class="number">-1</span> || (dist[matchR[v]]==dist[u]<span class="number">+1</span> &amp;&amp; <span class="built_in">dfs</span>(matchR[v])))</span><br><span class="line">        &#123;</span><br><span class="line">            matchL[u]=v, matchR[v]=u;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dist[u]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hopcroft_karp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(matchL, matchL+n<span class="number">+1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">fill</span>(matchR, matchR+m<span class="number">+1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>; u&lt;=n; u++) <span class="keyword">if</span>(matchL[u]==<span class="number">-1</span>) res+=<span class="built_in">dfs</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分图判定"><a href="#二分图判定" class="headerlink" title="二分图判定"></a>二分图判定</h3><p>用DFS染色法判断图是否为二分图，时间复杂度 $O(V+E)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> color[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u]=c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(color[v]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(color[v]==<span class="number">0</span> &amp;&amp; !<span class="built_in">dfs</span>(v, <span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="built_in">sizeof</span>(color));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span>(color[i]==<span class="number">0</span> &amp;&amp; !<span class="built_in">dfs</span>(i, <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2><h3 id="Dinic算法"><a href="#Dinic算法" class="headerlink" title="Dinic算法"></a>Dinic算法</h3><p><strong>单源单汇最大流</strong>，时间复杂度 $O(V^2E)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, cap, flow;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; edges;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> d[N], cur[N];</span><br><span class="line"><span class="type">int</span> n, m, s, t; <span class="comment">// s:源点, t:汇点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> cap)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edges.<span class="built_in">push_back</span>(&#123;v, cap, <span class="number">0</span>&#125;);</span><br><span class="line">    edges.<span class="built_in">push_back</span>(&#123;u, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    g[u].<span class="built_in">push_back</span>(edges.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">    g[v].<span class="built_in">push_back</span>(edges.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="built_in">sizeof</span>(d));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i: g[u])</span><br><span class="line">        &#123;</span><br><span class="line">            Edge &amp;e=edges[i];</span><br><span class="line">            <span class="keyword">if</span>(!d[e.to] &amp;&amp; e.cap&gt;e.flow)</span><br><span class="line">            &#123;</span><br><span class="line">                d[e.to]=d[u]<span class="number">+1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(e.to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==t || a==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">int</span> flow=<span class="number">0</span>, f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> &amp;i=cur[u]; i&lt;g[u].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Edge &amp;e=edges[g[u][i]];</span><br><span class="line">        <span class="keyword">if</span>(d[e.to]==d[u]<span class="number">+1</span> &amp;&amp; (f=<span class="built_in">dfs</span>(e.to, <span class="built_in">min</span>(a, e.cap-e.flow)))&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            e.flow+=f;</span><br><span class="line">            edges[g[u][i]^<span class="number">1</span>].flow-=f;</span><br><span class="line">            flow+=f;</span><br><span class="line">            a-=f;</span><br><span class="line">            <span class="keyword">if</span>(a==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxFlow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cur, <span class="number">0</span>, <span class="built_in">sizeof</span>(cur));</span><br><span class="line">        flow+=<span class="built_in">dfs</span>(s, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建模技巧"><a href="#建模技巧" class="headerlink" title="建模技巧"></a>建模技巧</h3><ul>
<li><strong>多源多汇</strong>：建超级源 $S$ 和超级汇 $T$，$S \to$ 所有源，所有汇 $\to T$，容量 $\infty$</li>
<li><strong>点容量</strong>：拆点，$u$ 拆成 $u<em>{in}$ 和 $u</em>{out}$，连边容量为点容量</li>
<li><strong>无向边</strong>：两个方向各加一条边</li>
<li><strong>流量下界 $[L,R]$</strong>：边容量改为 $R-L$，$S\to v$ 容量 $L$，$u\to T$ 容量 $L$</li>
<li><strong>最小割</strong>：最大流 = 最小割，最后BFS后从源点可达的点为 $S$ 集合</li>
</ul>
<h2 id="最小费用最大流"><a href="#最小费用最大流" class="headerlink" title="最小费用最大流"></a>最小费用最大流</h2><p>在最大流的基础上，使得总费用最小。常用于带费用的匹配、运输等问题。</p>
<p>每次找费用最小的增广路（用SPFA），直到无法增广。时间复杂度 $O(nmf)$，其中 $f$ 为流量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5005</span>, M=<span class="number">50005</span>;</span><br><span class="line"><span class="type">const</span> ll INF=<span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, nxt;</span><br><span class="line">    ll cap, cost;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[N], cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, m, s, t;</span><br><span class="line">ll maxflow, mincost;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, ll w, ll c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt]=&#123;v, head[u], w, c&#125;; head[u]=cnt;</span><br><span class="line">    e[++cnt]=&#123;u, head[v], <span class="number">0</span>, -c&#125;; head[v]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll dis[N], pre[N], flow[N];</span><br><span class="line"><span class="type">bool</span> inq[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(dis, dis+n<span class="number">+1</span>, INF);</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="built_in">sizeof</span>(inq));</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dis[s]=<span class="number">0</span>; inq[s]=<span class="number">1</span>;</span><br><span class="line">    flow[s]=INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        inq[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=head[u]; i; i=e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap&gt;<span class="number">0</span> &amp;&amp; dis[v]&gt;dis[u]+e[i].cost)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=dis[u]+e[i].cost;</span><br><span class="line">                pre[v]=i;</span><br><span class="line">                flow[v]=<span class="built_in">min</span>(flow[u], e[i].cap);</span><br><span class="line">                <span class="keyword">if</span>(!inq[v]) q.<span class="built_in">push</span>(v), inq[v]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[t]!=INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mcmf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    maxflow=mincost=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        maxflow+=flow[t];</span><br><span class="line">        mincost+=flow[t]*dis[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=t; i!=s; i=e[pre[i]^<span class="number">1</span>].to)</span><br><span class="line">        &#123;</span><br><span class="line">            e[pre[i]].cap-=flow[t];</span><br><span class="line">            e[pre[i]^<span class="number">1</span>].cap+=flow[t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">addEdge(u, v, cap, cost); // u-&gt;v 容量cap 费用cost</span></span><br><span class="line"><span class="comment">mcmf();</span></span><br><span class="line"><span class="comment">cout&lt;&lt;maxflow&lt;&lt;&quot; &quot;&lt;&lt;mincost&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="割点和桥（Tarjan）"><a href="#割点和桥（Tarjan）" class="headerlink" title="割点和桥（Tarjan）"></a>割点和桥（Tarjan）</h2><p>时间复杂度 $O(V+E)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; g[N];</span><br><span class="line"><span class="type">int</span> dfn[N], low[N], dfscnt=<span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> iscut[N]; <span class="comment">// 是否为割点</span></span><br><span class="line">vector&lt;pii&gt; bridges; <span class="comment">// 桥</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u]=low[u]=++dfscnt;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[v])</span><br><span class="line">        &#123;</span><br><span class="line">            child++;</span><br><span class="line">            <span class="built_in">tarjan</span>(v, u);</span><br><span class="line">            low[u]=<span class="built_in">min</span>(low[u], low[v]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断割点</span></span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;=dfn[u] &amp;&amp; fa!=<span class="number">-1</span>) iscut[u]=<span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断桥</span></span><br><span class="line">            <span class="keyword">if</span>(low[v]&gt;dfn[u]) bridges.<span class="built_in">push_back</span>(&#123;u, v&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u]=<span class="built_in">min</span>(low[u], dfn[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根节点的割点判断</span></span><br><span class="line">    <span class="keyword">if</span>(fa==<span class="number">-1</span> &amp;&amp; child&gt;<span class="number">1</span>) iscut[u]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">memset(dfn, 0, sizeof(dfn));</span></span><br><span class="line"><span class="comment">memset(iscut, false, sizeof(iscut));</span></span><br><span class="line"><span class="comment">bridges.clear();</span></span><br><span class="line"><span class="comment">for(int i=1; i&lt;=n; i++)</span></span><br><span class="line"><span class="comment">    if(!dfn[i]) tarjan(i, -1);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><p>树的直径是指树中任意两点间的最长路径。这里使用树形DP求解 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN];</span><br><span class="line"><span class="type">int</span> dia=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> max1=<span class="number">0</span>, max2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: tree[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> d=<span class="built_in">dfs</span>(v, u)<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;max1) max2=max1, max1=d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d&gt;max2) max2=d;</span><br><span class="line">    &#125;</span><br><span class="line">    dia=<span class="built_in">max</span>(dia, max1+max2);</span><br><span class="line">    <span class="keyword">return</span> max1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">treeDia</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dia=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> dia;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="倍增LCA"><a href="#倍增LCA" class="headerlink" title="倍增LCA"></a>倍增LCA</h2><p>通过倍增预处理节点的 $2^k$ 个祖先，使得可以在时间复杂度 $O(\log n)$ 找到任意两个节点的最近公共祖先。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG=<span class="number">17</span>; <span class="comment">// log2(n)的向上取整</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN];</span><br><span class="line"><span class="type">int</span> dep[MAXN], fa[MAXN][LOG];</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS初始化深度和直接父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    dep[root]=<span class="number">1</span>, fa[root][<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v: tree[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v==fa[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            dep[v]=dep[u]<span class="number">+1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>]=u;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理倍增表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">1</span>, n); <span class="comment">// 根节点为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;LOG; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[i][j<span class="number">-1</span>]==<span class="number">-1</span>) fa[i][j]=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> fa[i][j]=fa[fa[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将节点u向上移动k步</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">liftup</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;LOG; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k&amp;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">        &#123;</span><br><span class="line">            u=fa[u][j];</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到u和v的最近公共祖先</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u, v);</span><br><span class="line">    u=<span class="built_in">liftup</span>(u, dep[u]-dep[v]);</span><br><span class="line">    <span class="keyword">if</span>(u==v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=LOG<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">        <span class="keyword">if</span>(fa[u][j]!=fa[v][j])</span><br><span class="line">            u=fa[u][j], v=fa[v][j];</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求两点间的距离</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dis</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> w=<span class="built_in">lca</span>(u, v);</span><br><span class="line">    <span class="keyword">return</span> dep[u]+dep[v]<span class="number">-2</span>*dep[w];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用之前记得init()</span></span><br></pre></td></tr></table></figure>
<h2 id="Tarjan算法（离线）"><a href="#Tarjan算法（离线）" class="headerlink" title="Tarjan算法（离线）"></a>Tarjan算法（离线）</h2><p>Tarjan算法（离线）可以高效地解决LCA的问题 $O(n+\alpha(n))$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fa, sz;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> _n)</span><br><span class="line">    &#123;</span><br><span class="line">        n=_n;</span><br><span class="line">        fa.<span class="built_in">resize</span>(n);</span><br><span class="line">        sz.<span class="built_in">resize</span>(n, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) fa[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[x]!=x) fa[x]=<span class="built_in">find</span>(fa[x]);</span><br><span class="line">        <span class="keyword">return</span> fa[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ra=<span class="built_in">find</span>(x), rb=<span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(ra!=rb)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sz[ra]&lt;sz[rb]) <span class="built_in">swap</span>(ra, rb);</span><br><span class="line">            fa[rb]=ra;</span><br><span class="line">            sz[ra]+=sz[rb];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN];</span><br><span class="line">vector&lt;pii&gt; query[MAXN];  <span class="comment">// query[u]=(v,query_id)</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ancestor, ans;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, DSU&amp; dsu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ancestor[u]=u;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: tree[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">tarjan</span>(v, u, dsu);</span><br><span class="line">        dsu.<span class="built_in">unite</span>(u, v);</span><br><span class="line">        ancestor[dsu.<span class="built_in">find</span>(u)]=u;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;[v, idx]: query[u]) <span class="keyword">if</span>(vis[v])</span><br><span class="line">        ans[idx]=ancestor[dsu.<span class="built_in">find</span>(v)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用前记得初始化</span></span><br><span class="line"><span class="comment">DSU dsu(n+1);</span></span><br><span class="line"><span class="comment">ancestor.resize(n+1);</span></span><br><span class="line"><span class="comment">vis.resize(n+1,false);</span></span><br><span class="line"><span class="comment">ans.resize(t); // t个查询</span></span><br><span class="line"><span class="comment">//然后在query中加入查询</span></span><br><span class="line"><span class="comment">for(int i=0; i&lt;m; i++)</span></span><br><span class="line"><span class="comment">query[u].push_back(&#123;v, i&#125;);</span></span><br><span class="line"><span class="comment">query[v].push_back(&#123;u, i&#125;);</span></span><br><span class="line"><span class="comment">//然后tarjan(1,0,dsu);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><code>STL</code>的容器本身提供了一些字符串的算法：</p>
<ul>
<li><code>unordered_map</code>的原理是哈希表，可以用来快速查找字符串。</li>
<li><code>string</code>的<code>substr((int/size_t)pos, len)</code> 函数可以用来截取子串。</li>
<li><code>string</code>的<code>find()</code>函数可以用来查找子串。找到，返回子串在原串中的起始位置（下标<code>size_t</code>）， 否则返回<code>string::npos</code>。</li>
<li><code>string</code>的<code>replace(pos, len, str)</code>函数可以用来替换子串，从<code>pos</code>开始长度为<code>len</code>的子串被替换为<code>str</code>。</li>
<li><code>reverse()</code>函数可以用来反转字符串。</li>
</ul>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP用于快速匹配字符串，时间复杂度 $O(n+m)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">KMP</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// next array</span></span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>(), m=p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nxt</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; p[i]!=p[j]) j=nxt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j]) j++;</span><br><span class="line">        nxt[i]=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// search</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i]!=p[j]) j=nxt[j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j==m)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i-m<span class="number">+1</span>);</span><br><span class="line">            j=nxt[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">How to ues:</span></span><br><span class="line"><span class="comment">string s=&quot;abcabcaaabcaabccbabca&quot;, p=&quot;abc&quot;;</span></span><br><span class="line"><span class="comment">auto pos=KMP(s, p);</span></span><br><span class="line"><span class="comment">for(auto i: pos) cout&lt;&lt;i&lt;&lt;&#x27; &#x27;; // output initial the match positions</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Z-Algorithm"><a href="#Z-Algorithm" class="headerlink" title="Z-Algorithm"></a>Z-Algorithm</h2><p>Z-Algorithm用于快速找到字符串的所有子串与其自身匹配的位置，时间复杂度 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Z_Algo</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">z</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;=r) z[i]=<span class="built_in">min</span>(r-i<span class="number">+1</span>, z[i-l]);</span><br><span class="line">        <span class="keyword">while</span>(i+z[i]&lt;n &amp;&amp; s[z[i]]==s[i+z[i]]) z[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+z[i]<span class="number">-1</span>&gt;r) l=i, r=i+z[i]<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">find</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">const</span> string&amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t=p+<span class="string">&#x27;#&#x27;</span>+s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; z=<span class="built_in">Z_Algo</span>(t);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> m=p.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m<span class="number">+1</span>; i&lt;(<span class="type">int</span>)t.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">if</span>(z[i]&gt;=m) res.<span class="built_in">push_back</span>(i-m<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">How to ues:</span></span><br><span class="line"><span class="comment">string s=&quot;abcabcaaabcaabccbabca&quot;, p=&quot;abc&quot;;</span></span><br><span class="line"><span class="comment">auto pos=find(s, p); // output initial the match positions</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="Trie树（字典树）"><a href="#Trie树（字典树）" class="headerlink" title="Trie树（字典树）"></a>Trie树（字典树）</h2><p>Trie树用于快速插入、查找、删除、前缀匹配单词，时间复杂度 $O(n)$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span></span><br><span class="line">&#123;</span><br><span class="line">    Trie* ch[<span class="number">26</span>];</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">    <span class="built_in">Trie</span>(): <span class="built_in">isEnd</span>(<span class="literal">false</span>), <span class="built_in">cnt</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in">sizeof</span>(ch));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(Trie* root, <span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie* p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> idx=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;ch[idx]) p-&gt;ch[idx]=<span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        p=p-&gt;ch[idx];</span><br><span class="line">        p-&gt;cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;isEnd=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(Trie* root, <span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie* p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;ch[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        p=p-&gt;ch[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;isEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prefixCnt</span><span class="params">(Trie* root, <span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Trie* p=root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;ch[u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=p-&gt;ch[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先检查find(s)，再erase(s)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">erase</span><span class="params">(Trie* root, <span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">find</span>(root, s)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    Trie* p=root;</span><br><span class="line">    vector&lt;Trie*&gt; path;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        p=p-&gt;ch[u];</span><br><span class="line">        path.<span class="built_in">push_back</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;isEnd=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=(<span class="type">int</span>)s.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) path[i]-&gt;cnt--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">How to ues:</span></span><br><span class="line"><span class="comment">Trie* root=new Trie();</span></span><br><span class="line"><span class="comment">insert(root, &quot;abc&quot;);</span></span><br><span class="line"><span class="comment">insert(root, &quot;ab&quot;);</span></span><br><span class="line"><span class="comment">insert(root, &quot;abcd&quot;);</span></span><br><span class="line"><span class="comment">cout&lt;&lt;find(root, &quot;abc&quot;)&lt;&lt;endl; // output 1</span></span><br><span class="line"><span class="comment">cout&lt;&lt;prefixCnt(root, &quot;ab&quot;)&lt;&lt;endl; // output 3</span></span><br><span class="line"><span class="comment">erase(root, &quot;abcd&quot;);</span></span><br><span class="line"><span class="comment">cout&lt;&lt;find(root, &quot;abcd&quot;)&lt;&lt;endl; // output 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Manacher算法"><a href="#Manacher算法" class="headerlink" title="Manacher算法"></a>Manacher算法</h2><p>求字符串的最长回文子串，时间复杂度 $O(n)$。</p>
<p>通过在字符间插入特殊字符（如<code>#</code>）统一处理奇偶长度回文串。维护回文中心和右边界，利用对称性减少重复计算。$p[i]$ 表示以 $i$ 为中心的最长回文半径。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">manacher</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s) t+=c, t+=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n=t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>, id=<span class="number">0</span>; <span class="comment">// mx为最右边界，id为对应中心</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=(i&lt;mx)? <span class="built_in">min</span>(p[<span class="number">2</span>*id-i], mx-i): <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i-p[i]&gt;=<span class="number">0</span> &amp;&amp; i+p[i]&lt;n &amp;&amp; t[i-p[i]]==t[i+p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]&gt;mx) mx=i+p[i], id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找最长回文</span></span><br><span class="line">    <span class="type">int</span> maxLen=<span class="number">0</span>, center=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i]<span class="number">-1</span>&gt;maxLen)</span><br><span class="line">        &#123;</span><br><span class="line">            maxLen=p[i]<span class="number">-1</span>;</span><br><span class="line">            center=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> start=(center-maxLen)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回所有位置的最长回文半径</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">manacher_array</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string t=<span class="string">&quot;#&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s) t+=c, t+=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> n=t.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">0</span>, id=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i]=(i&lt;mx)? <span class="built_in">min</span>(p[<span class="number">2</span>*id-i], mx-i): <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i-p[i]&gt;=<span class="number">0</span> &amp;&amp; i+p[i]&lt;n &amp;&amp; t[i-p[i]]==t[i+p[i]]) p[i]++;</span><br><span class="line">        <span class="keyword">if</span>(i+p[i]&gt;mx) mx=i+p[i], id=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// p[i]-1为原串中以i/2为中心的最长回文长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>多模式串匹配，在文本串中查找多个模式串的所有出现位置。时间复杂度 $O(n+m+z)$，$n$ 为文本长度，$m$ 为模式串总长度，$z$ 为匹配次数。</p>
<p>在Trie树基础上加上失配指针（类似KMP的next数组），失配时跳转到最长后缀对应节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AC</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tr[MAXN][<span class="number">26</span>], fail[MAXN], cnt[MAXN];</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        idx=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr[<span class="number">0</span>], <span class="number">0</span>, <span class="built_in">sizeof</span>(tr[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(!tr[p][u])</span><br><span class="line">            &#123;</span><br><span class="line">                tr[p][u]=++idx;</span><br><span class="line">                <span class="built_in">memset</span>(tr[idx], <span class="number">0</span>, <span class="built_in">sizeof</span>(tr[idx]));</span><br><span class="line">                cnt[idx]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=tr[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(tr[<span class="number">0</span>][i]) q.<span class="built_in">push</span>(tr[<span class="number">0</span>][i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">26</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tr[u][i])</span><br><span class="line">                &#123;</span><br><span class="line">                    fail[tr[u][i]]=tr[fail[u]][i];</span><br><span class="line">                    q.<span class="built_in">push</span>(tr[u][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> tr[u][i]=tr[fail[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>, res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)</span><br><span class="line">        &#123;</span><br><span class="line">            p=tr[p][c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=p; j &amp;&amp; cnt[j]!=<span class="number">-1</span>; j=fail[j])</span><br><span class="line">            &#123;</span><br><span class="line">                res+=cnt[j];</span><br><span class="line">                cnt[j]=<span class="number">-1</span>; <span class="comment">// 标记已访问，避免重复计数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">AC ac;</span></span><br><span class="line"><span class="comment">ac.init();</span></span><br><span class="line"><span class="comment">ac.insert(&quot;she&quot;);</span></span><br><span class="line"><span class="comment">ac.insert(&quot;he&quot;);</span></span><br><span class="line"><span class="comment">ac.insert(&quot;her&quot;);</span></span><br><span class="line"><span class="comment">ac.build();</span></span><br><span class="line"><span class="comment">cout&lt;&lt;ac.query(&quot;sherhershe&quot;)&lt;&lt;endl; // 输出匹配次数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h2><p>对字符串的所有后缀进行排序，支持快速查询最长公共前缀（LCP）、子串查找等。时间复杂度 $O(n\log n)$。</p>
<p>倍增法构造后缀数组。$sa[i]$ 表示排名第 $i$ 的后缀的起始位置，$rk[i]$ 表示起始位置为 $i$ 的后缀的排名，$height[i]$ 表示 $sa[i]$ 和 $sa[i-1]$ 的最长公共前缀长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">int</span> sa[N], rk[N], oldrk[N], id[N], cnt[N];</span><br><span class="line">    <span class="type">int</span> height[N]; <span class="comment">// height[i] = lcp(sa[i], sa[i-1])</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n=s.<span class="built_in">size</span>();</span><br><span class="line">        m=<span class="built_in">max</span>(n, <span class="number">300</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 倍增构造SA</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cnt[rk[i]=s[i<span class="number">-1</span>]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--) sa[cnt[rk[i]]--]=i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> w=<span class="number">1</span>; w&lt;n; w&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;n-w; i--) id[++p]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="keyword">if</span>(sa[i]&gt;w) id[++p]=sa[i]-w;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) cnt[rk[id[i]]]++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) cnt[i]+=cnt[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=n; i&gt;=<span class="number">1</span>; i--) sa[cnt[rk[id[i]]]--]=id[i];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">memcpy</span>(oldrk, rk, <span class="built_in">sizeof</span>(rk));</span><br><span class="line">            p=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(oldrk[sa[i]]==oldrk[sa[i<span class="number">-1</span>]] &amp;&amp; </span><br><span class="line">                   oldrk[sa[i]+w]==oldrk[sa[i<span class="number">-1</span>]+w]) rk[sa[i]]=p;</span><br><span class="line">                <span class="keyword">else</span> rk[sa[i]]=++p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p==n) <span class="keyword">break</span>;</span><br><span class="line">            m=p;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 构造height数组</span></span><br><span class="line">        <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(rk[i]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(k) k--;</span><br><span class="line">            <span class="type">int</span> j=sa[rk[i]<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">while</span>(i+k&lt;=n &amp;&amp; j+k&lt;=n &amp;&amp; s[i+k<span class="number">-1</span>]==s[j+k<span class="number">-1</span>]) k++;</span><br><span class="line">            height[rk[i]]=k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求lcp(后缀i, 后缀j)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lcp</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==j) <span class="keyword">return</span> n-i<span class="number">+1</span>;</span><br><span class="line">        <span class="keyword">if</span>(rk[i]&gt;rk[j]) <span class="built_in">swap</span>(i, j);</span><br><span class="line">        <span class="type">int</span> ans=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=rk[i]<span class="number">+1</span>; k&lt;=rk[j]; k++)</span><br><span class="line">            ans=<span class="built_in">min</span>(ans, height[k]);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">SA sa;</span></span><br><span class="line"><span class="comment">string s=&quot;banana&quot;;</span></span><br><span class="line"><span class="comment">sa.build(s);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// sa.sa[i] 为排名第i的后缀起始位置</span></span><br><span class="line"><span class="comment">for(int i=1; i&lt;=s.size(); i++)</span></span><br><span class="line"><span class="comment">    cout&lt;&lt;s.substr(sa.sa[i]-1)&lt;&lt;endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 求最长公共前缀</span></span><br><span class="line"><span class="comment">cout&lt;&lt;sa.lcp(1, 4)&lt;&lt;endl; // banana 和 ana 的LCP</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="应用：最长重复子串"><a href="#应用：最长重复子串" class="headerlink" title="应用：最长重复子串"></a>应用：最长重复子串</h3><p>求字符串中最长的重复子串。</p>
<p><strong>思路</strong>：最长重复子串即为任意两个后缀的最长公共前缀的最大值，即 $\max(height[i])$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cnt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SA sa;</span><br><span class="line">    sa.<span class="built_in">build</span>(s);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans, sa.height[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="应用：不同子串个数"><a href="#应用：不同子串个数" class="headerlink" title="应用：不同子串个数"></a>应用：不同子串个数</h3><p>求字符串中不同子串的个数。</p>
<p><strong>思路</strong>：总子串数为 $\frac{n(n+1)}{2}$，减去重复的（即相邻后缀的LCP）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">cnt</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SA sa;</span><br><span class="line">    sa.<span class="built_in">build</span>(s);</span><br><span class="line">    <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">    ll ans=(ll)n*(n<span class="number">+1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++)</span><br><span class="line">        ans-=sa.height[i];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0/1背包"></a>0/1背包</h3><p>有 $n$ 种物品和一个容量为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$，价值为 $v_i$，<strong>每种物品只有一件</strong>，求解将哪些物品装入背包使总价值最大。</p>
<p><strong>思路</strong>：$dp[i][j]$ 表示前 $i$ 件物品放入容量为 $j$ 的背包的最大价值。对于第 $i$ 件物品，要么不选，要么选，取最大值。空间优化后用一维数组，<strong>逆序枚举容量</strong>保证每件物品只用一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, V; <span class="comment">// n个物品, 背包容量V</span></span><br><span class="line"><span class="type">int</span> w[N], v[N]; <span class="comment">// 重量, 价值</span></span><br><span class="line"><span class="type">int</span> dp[N]; <span class="comment">// dp[j]表示容量为j时的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=V; j&gt;=w[i]; j--)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>有 $n$ 种物品和一个容量为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$，价值为 $v_i$，<strong>每种物品有无限件</strong>，求解将哪些物品装入背包使总价值最大。</p>
<p><strong>思路</strong>：与0/1背包的区别是每种物品可以选无限次，<strong>正序枚举容量</strong>即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=w[i]; j&lt;=V; j++)</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]]+v[i]);</span><br></pre></td></tr></table></figure>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>有 $n$ 种物品和一个容量为 $V$ 的背包，第 $i$ 种物品的体积为 $w_i$，价值为 $v_i$，<strong>数量为 $s_i$</strong>，求解将哪些物品装入背包使总价值最大。</p>
<p><strong>思路</strong>：朴素做法是对每种物品枚举选几个，时间复杂度 $O(V\sum s_i)$。<strong>二进制优化</strong>：将 $s_i$ 个物品拆分成 $1,2,4,\ldots,2^k$ 和剩余部分，转化为0/1背包，时间复杂度 $O(V\sum\log s_i)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> s[N]; <span class="comment">// 数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制优化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=num; k&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num-=k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=V; j&gt;=w[i]*k; j--)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]*k]+v[i]*k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=V; j&gt;=w[i]*num; j--)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]*num]+v[i]*num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p>放入背包的物品可能只有1件（0/1背包），也可能有无限件（完全背包），也可能有可数的几件（多重背包）。</p>
<p><strong>思路</strong>：分类讨论，根据物品类型选择对应的背包方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s=-1:0/1背包, s=0:完全背包, s&gt;0:多重背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="number">-1</span>) <span class="comment">// 0/1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=V; j&gt;=w[i]; j--)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]]+v[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="number">0</span>) <span class="comment">// 完全</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=w[i]; j&lt;=V; j++)</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]]+v[i]);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 多重(二进制优化)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> num=s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=num; k&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num-=k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=V; j&gt;=w[i]*k; j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]*k]+v[i]*k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=V; j&gt;=w[i]*num; j--)</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j], dp[j-w[i]*num]+v[i]*num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维背包"><a href="#二维背包" class="headerlink" title="二维背包"></a>二维背包</h3><p>背包有<strong>两个容量限制</strong>（如重量和体积），第 $i$ 种物品的重量为 $w_i$，体积为 $vol_i$，价值为 $v_i$。</p>
<p><strong>思路</strong>：在0/1背包基础上，状态增加一维，枚举两个维度的容量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][N]; <span class="comment">// dp[i][j]表示重量i、体积j时的最大价值</span></span><br><span class="line"><span class="type">int</span> w[N], v[N], vol[N]; </span><br><span class="line"><span class="type">int</span> W, VOL; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=W; j&gt;=w[i]; j--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=VOL; k&gt;=vol[i]; k--)</span><br><span class="line">            dp[j][k]=<span class="built_in">max</span>(dp[j][k], dp[j-w[i]][k-vol[i]]+v[i]);</span><br></pre></td></tr></table></figure>
<h2 id="最长上升子序列（LIS）"><a href="#最长上升子序列（LIS）" class="headerlink" title="最长上升子序列（LIS）"></a>最长上升子序列（LIS）</h2><p>给定长度为 $n$ 的序列，求严格递增的最长子序列长度。</p>
<p><strong>思路</strong>：朴素DP为 $O(n^2)$。优化方法：维护数组 $d[i]$ 表示长度为 $i+1$ 的上升子序列末尾元素的最小值，该数组单调递增，可用二分查找优化到 $O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// O(nlogn) 版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x: a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pos=<span class="built_in">lower_bound</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), x)-d.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(pos==d.<span class="built_in">size</span>()) d.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">else</span> d[pos]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最长不下降（允许相等）：lower_bound改为upper_bound</span></span><br></pre></td></tr></table></figure>
<h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><p>给定两个字符串 $a,b$，求它们的最长公共子序列长度。</p>
<p><strong>思路</strong>：</p>
<p>$dp[i][j]$ 表示 $a$ 的前 $i$ 个字符和 $b$ 的前 $j$ 个字符的LCS长度。</p>
<p>若 $a[i]=b[j]$ 则 $dp[i][j]=dp[i-1][j-1]+1$，否则 $dp[i][j]=\max(dp[i-1][j],dp[i][j-1])$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>(), m=b.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]<span class="number">+1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><p>用二进制表示状态集合，适用于 $n \le 20$ 的小规模问题。</p>
<p><strong>思路</strong>：用整数的二进制位表示集合，第 $i$ 位为1表示第 $i$ 个元素在集合中。常用操作：<code>S|(1&lt;&lt;i)</code> 加入元素，<code>S&amp;(~(1&lt;&lt;i))</code> 删除元素，<code>S&amp;(1&lt;&lt;i)</code> 判断是否在集合中。</p>
<h3 id="旅行商问题（TSP）"><a href="#旅行商问题（TSP）" class="headerlink" title="旅行商问题（TSP）"></a>旅行商问题（TSP）</h3><p>有 $n$ 个城市，已知任意两城市间距离，从城市0出发访问所有城市恰好一次再回到0，求最短路径。</p>
<p><strong>思路</strong>：$dp[S][i]$ 表示已访问城市集合为 $S$，当前在城市 $i$ 的最短路径长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, dist[N][N];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1</span>&lt;&lt;N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TSP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>; S&lt;(<span class="number">1</span>&lt;&lt;n); S++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!(S&amp;(<span class="number">1</span>&lt;&lt;i))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                <span class="keyword">if</span>(!(S&amp;(<span class="number">1</span>&lt;&lt;j)))</span><br><span class="line">                    dp[S|(<span class="number">1</span>&lt;&lt;j)][j]=<span class="built_in">min</span>(dp[S|(<span class="number">1</span>&lt;&lt;j)][j], dp[S][i]+dist[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> ans=INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        ans=<span class="built_in">min</span>(ans, dp[(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>][i]+dist[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子集枚举"><a href="#子集枚举" class="headerlink" title="子集枚举"></a>子集枚举</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举S的所有子集（不含空集）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> sub=S; sub; sub=(sub<span class="number">-1</span>)&amp;S)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理子集sub</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状压DP-棋盘放置"><a href="#状压DP-棋盘放置" class="headerlink" title="状压DP - 棋盘放置"></a>状压DP - 棋盘放置</h3><p>在 $n\times m$ 棋盘上放置方块，相邻格子不能同时放置，求方案数。</p>
<p><strong>思路</strong>：$dp[i][S]$ 表示前 $i$ 行已放置，第 $i$ 行状态为 $S$ 的方案数。预处理合法状态（同一行不相邻），转移时检查相邻行不冲突。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">ll dp[N][<span class="number">1</span>&lt;&lt;M];</span><br><span class="line"><span class="type">bool</span> ok[<span class="number">1</span>&lt;&lt;M];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>; S&lt;(<span class="number">1</span>&lt;&lt;m); S++)</span><br><span class="line">    ok[S]=!((S&amp;(S&lt;&lt;<span class="number">1</span>))); <span class="comment">// 预处理合法状态</span></span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> S=<span class="number">0</span>; S&lt;(<span class="number">1</span>&lt;&lt;m); S++)</span><br><span class="line">        <span class="keyword">if</span>(ok[S])</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> nS=<span class="number">0</span>; nS&lt;(<span class="number">1</span>&lt;&lt;m); nS++)</span><br><span class="line">                <span class="keyword">if</span>(ok[nS] &amp;&amp; !(S&amp;nS))</span><br><span class="line">                    dp[i<span class="number">+1</span>][nS]+=dp[i][S];</span><br></pre></td></tr></table></figure>
<h2 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h2><p>统计区间 $[L,R]$ 内满足某种数位条件的数的个数。</p>
<p><strong>思路</strong>：记忆化搜索，按位枚举数字，维护状态和约束条件。<code>limit</code> 表示是否贴上界，<code>lead</code> 表示是否有前导零。答案为 $solve(R)-solve(L-1)$。</p>
<h3 id="例：不含连续49的数的个数"><a href="#例：不含连续49的数的个数" class="headerlink" title="例：不含连续49的数的个数"></a>例：不含连续49的数的个数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ll dp[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> pre, <span class="type">bool</span> limit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!limit &amp;&amp; vis[pos][pre]) <span class="keyword">return</span> dp[pos][pre];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> up=limit? a[pos]: <span class="number">9</span>;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=up; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre==<span class="number">1</span> &amp;&amp; i==<span class="number">9</span>) <span class="keyword">continue</span>; <span class="comment">// 上一位是4，这一位是9，跳过</span></span><br><span class="line">        res+=<span class="built_in">dfs</span>(pos<span class="number">-1</span>, i==<span class="number">4</span>, limit&amp;&amp;i==up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!limit) vis[pos][pre]=<span class="literal">true</span>, dp[pos][pre]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) a[++len]=x%<span class="number">10</span>, x/=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(len, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 答案：solve(R) - solve(L-1)</span></span><br></pre></td></tr></table></figure>
<h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><h3 id="树的最大独立集"><a href="#树的最大独立集" class="headerlink" title="树的最大独立集"></a>树的最大独立集</h3><p>在树上选择若干个不相邻的节点，使权值和最大。</p>
<p><strong>思路</strong>：$dp[u][0]$ 表示不选 $u$ 的最大权值，$dp[u][1]$ 表示选 $u$ 的最大权值。若选 $u$ 则子节点都不能选。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> w[N], dp[N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>]=<span class="number">0</span>; dp[u][<span class="number">1</span>]=w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: tree[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        dp[u][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">        dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 答案：max(dp[1][0], dp[1][1])</span></span><br></pre></td></tr></table></figure>
<h3 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h3><p>在树上选 $k$ 个节点使权值和最大。</p>
<p><strong>思路</strong>：$dp[u][j]$ 表示 $u$ 子树中选 $j$ 个节点的最大权值。合并子树时类似背包DP。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[N][N], sz[N], k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>; dp[u][<span class="number">1</span>]=w[u];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: tree[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="built_in">min</span>(k, sz[u]); i&gt;=<span class="number">1</span>; i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=<span class="built_in">min</span>(k-i, sz[v]); j++)</span><br><span class="line">                dp[u][i+j]=<span class="built_in">max</span>(dp[u][i+j], dp[u][i]+dp[v][j]);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>有 $n$ 堆石子排成一行，每次可以合并相邻的两堆，代价为两堆石子数量之和，求合并成一堆的最小代价。</p>
<p><strong>思路</strong>：$dp[i][j]$ 表示合并区间 $[i,j]$ 的最小代价。枚举分割点 $k$，$dp[i][j]=\min(dp[i][k]+dp[k+1][j]+sum[i,j])$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[N], sum[N], dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">2</span>; len&lt;=n; len++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i+len<span class="number">-1</span>&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">        dp[i][j]=INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;j; k++)</span><br><span class="line">            dp[i][j]=<span class="built_in">min</span>(dp[i][j], dp[i][k]+dp[k<span class="number">+1</span>][j]+sum[j]-sum[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 答案：dp[1][n]</span></span><br></pre></td></tr></table></figure>
<h3 id="环形石子合并"><a href="#环形石子合并" class="headerlink" title="环形石子合并"></a>环形石子合并</h3><p>石子排成一圈，求最小代价。</p>
<p><strong>思路</strong>：破环成链，复制一份接在后面，枚举起点，取长度为 $n$ 的区间的最小值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++) a[i+n]=a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*n; i++) sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="comment">// 同上DP，枚举len从2到n</span></span><br><span class="line"><span class="type">int</span> ans=INT_MAX;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    ans=<span class="built_in">min</span>(ans, dp[i][i+n<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="其他经典DP"><a href="#其他经典DP" class="headerlink" title="其他经典DP"></a>其他经典DP</h2><h3 id="最大子段和（Kadane算法）"><a href="#最大子段和（Kadane算法）" class="headerlink" title="最大子段和（Kadane算法）"></a>最大子段和（Kadane算法）</h3><p>给定数组，求最大连续子段和。</p>
<p><strong>思路</strong>：$dp[i]$ 表示以 $i$ 结尾的最大子段和，$dp[i]=\max(a[i], dp[i-1]+a[i])$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll ans=LLONG_MIN, sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x: a)</span><br><span class="line">    &#123;</span><br><span class="line">        sum=<span class="built_in">max</span>((ll)x, sum+x);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h3><p>给定二维矩阵，求最大子矩阵和。</p>
<p><strong>思路</strong>：枚举上下边界，将列压缩成一维数组，转化为最大子段和问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">maxSubMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=mat.<span class="built_in">size</span>(), m=mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    ll ans=LLONG_MIN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> up=<span class="number">0</span>; up&lt;n; up++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vector&lt;ll&gt; <span class="title">sum</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> down=up; down&lt;n; down++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++) sum[j]+=mat[down][j];</span><br><span class="line">            ll cur=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;m; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                cur=<span class="built_in">max</span>(sum[j], cur+sum[j]);</span><br><span class="line">                ans=<span class="built_in">max</span>(ans, cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>将字符串 $a$ 变成 $b$，可以插入、删除、替换字符，求最少操作次数。</p>
<p><strong>思路</strong>：$dp[i][j]$ 表示 $a$ 的前 $i$ 个字符变成 $b$ 的前 $j$ 个字符的最少操作数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistance</span><span class="params">(<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n=a.<span class="built_in">size</span>(), m=b.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=n; i++) dp[i][<span class="number">0</span>]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=m; j++) dp[<span class="number">0</span>][j]=j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i<span class="number">-1</span>]==b[j<span class="number">-1</span>]) dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="built_in">min</span>(&#123;dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;)<span class="number">+1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h1><p>有的时候实在想不到更优的方法，可以尝试将暴力方法优化。</p>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>将大范围的数据映射到小范围，常用于值域很大但数据量较小的情况。</p>
<p>将数值映射到 $[1,n]$ 的连续整数，保持相对大小关系不变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本离散化</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; a; <span class="comment">// 原始数据</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b=a; <span class="comment">// 备份用于映射</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">b.<span class="built_in">erase</span>(<span class="built_in">unique</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>()), b.<span class="built_in">end</span>()); <span class="comment">// 去重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化：将a[i]映射到[1,len]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;a.<span class="built_in">size</span>(); i++)</span><br><span class="line">    a[i]=<span class="built_in">lower_bound</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>(), a[i])-b.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还原：从离散化值还原为原值</span></span><br><span class="line"><span class="type">int</span> original_val=b[a[i]<span class="number">-1</span>];</span><br></pre></td></tr></table></figure>
<h3 id="区间离散化"><a href="#区间离散化" class="headerlink" title="区间离散化"></a>区间离散化</h3><p>处理区间问题时，需要离散化区间端点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;pii&gt; segs; <span class="comment">// 区间 &#123;l, r&#125;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [l, r]: segs)</span><br><span class="line">&#123;</span><br><span class="line">    nums.<span class="built_in">push_back</span>(l);</span><br><span class="line">    nums.<span class="built_in">push_back</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">nums.<span class="built_in">erase</span>(<span class="built_in">unique</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()), nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询x离散化后的值</span></span><br><span class="line"><span class="keyword">auto</span> getID = [&amp;](<span class="type">int</span> x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), x)-nums.<span class="built_in">begin</span>()<span class="number">+1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="莫队算法"><a href="#莫队算法" class="headerlink" title="莫队算法"></a>莫队算法</h2><p>离线处理区间查询问题，时间复杂度 $O(n\sqrt{n})$。适用于<strong>可增量维护</strong>的区间信息。</p>
<p>将询问按照左端点所在块排序，相同块内按右端点排序。通过移动左右指针，增量维护答案。</p>
<h3 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, blockSize;</span><br><span class="line"><span class="type">int</span> a[N], cnt[N], ans[N];</span><br><span class="line"><span class="type">int</span> curAns=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, id;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Query &amp;q) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l/blockSize!=q.l/blockSize) <span class="keyword">return</span> l&lt;q.l;</span><br><span class="line">        <span class="keyword">return</span> (l/blockSize)&amp;<span class="number">1</span>? r&lt;q.r: r&gt;q.r; <span class="comment">// 奇偶优化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加入位置pos的元素</span></span><br><span class="line">    <span class="keyword">if</span>(++cnt[a[pos]]==<span class="number">1</span>) curAns++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 删除位置pos的元素</span></span><br><span class="line">    <span class="keyword">if</span>(--cnt[a[pos]]==<span class="number">0</span>) curAns--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    blockSize=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="built_in">sort</span>(q, q+m);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>, r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;q[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;q[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;q[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;q[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        ans[q[i].id]=curAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带修改莫队"><a href="#带修改莫队" class="headerlink" title="带修改莫队"></a>带修改莫队</h3><p>支持单点修改的莫队，时间复杂度 $O(n^{5/3})$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, qcnt, mcnt, blockSize;</span><br><span class="line"><span class="type">int</span> a[N], cnt[N], ans[N];</span><br><span class="line"><span class="type">int</span> curAns=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r, t, id; <span class="comment">// t为时间戳</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Query &amp;q) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l/blockSize!=q.l/blockSize) <span class="keyword">return</span> l&lt;q.l;</span><br><span class="line">        <span class="keyword">if</span>(r/blockSize!=q.r/blockSize) <span class="keyword">return</span> r&lt;q.r;</span><br><span class="line">        <span class="keyword">return</span> t&lt;q.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;queries[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Modify</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pos, val; <span class="comment">// 将pos位置修改为val</span></span><br><span class="line">&#125;modifies[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123; <span class="keyword">if</span>(++cnt[a[pos]]==<span class="number">1</span>) curAns++; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123; <span class="keyword">if</span>(--cnt[a[pos]]==<span class="number">0</span>) curAns--; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">applyModify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=modifies[i].pos &amp;&amp; modifies[i].pos&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">del</span>(modifies[i].pos);</span><br><span class="line">        <span class="built_in">swap</span>(a[modifies[i].pos], modifies[i].val);</span><br><span class="line">        <span class="built_in">add</span>(modifies[i].pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">swap</span>(a[modifies[i].pos], modifies[i].val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    blockSize=<span class="built_in">pow</span>(n, <span class="number">2.0</span>/<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">sort</span>(queries, queries+qcnt);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l=<span class="number">1</span>, r=<span class="number">0</span>, t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;qcnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;queries[i].l) <span class="built_in">add</span>(--l);</span><br><span class="line">        <span class="keyword">while</span>(r&lt;queries[i].r) <span class="built_in">add</span>(++r);</span><br><span class="line">        <span class="keyword">while</span>(l&lt;queries[i].l) <span class="built_in">del</span>(l++);</span><br><span class="line">        <span class="keyword">while</span>(r&gt;queries[i].r) <span class="built_in">del</span>(r--);</span><br><span class="line">        <span class="keyword">while</span>(t&lt;queries[i].t) <span class="built_in">applyModify</span>(++t, l, r);</span><br><span class="line">        <span class="keyword">while</span>(t&gt;queries[i].t) <span class="built_in">applyModify</span>(t--, l, r);</span><br><span class="line">        ans[queries[i].id]=curAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CDQ分治"><a href="#CDQ分治" class="headerlink" title="CDQ分治"></a>CDQ分治</h2><p>处理三维偏序、动态规划优化等问题，时间复杂度 $O(n\log^2 n)$。</p>
<p>核心思想：分治时只统计左半部分对右半部分的贡献。</p>
<h3 id="三维偏序问题"><a href="#三维偏序问题" class="headerlink" title="三维偏序问题"></a>三维偏序问题</h3><p>给定 $n$ 个三元组 $(a_i,b_i,c_i)$，求每个点的支配数（有多少个点三维都 $\le$ 它）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, c, ans, cnt;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point &amp;p) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a==p.a &amp;&amp; b==p.b &amp;&amp; c==p.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, bit[N], maxc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x&lt;=maxc; x+=x&amp;-x) bit[x]+=v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x-=x&amp;-x) res+=bit[x];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cdq</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cdq</span>(l, mid); <span class="built_in">cdq</span>(mid<span class="number">+1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 归并排序，按b排序</span></span><br><span class="line">    <span class="type">int</span> i=l, j=mid<span class="number">+1</span>, k=l;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i].b&lt;=p[j].b)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">add</span>(p[i].c, p[i].cnt);</span><br><span class="line">            tmp[k++]=p[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[j].ans+=<span class="built_in">query</span>(p[j].c);</span><br><span class="line">            tmp[k++]=p[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) p[j].ans+=<span class="built_in">query</span>(p[j].c), tmp[k++]=p[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=l; t&lt;i; t++) <span class="built_in">add</span>(p[t].c, -p[t].cnt);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) tmp[k++]=p[i++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> t=l; t&lt;=r; t++) p[t]=tmp[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">1. 先对a排序</span></span><br><span class="line"><span class="comment">2. 相同的点合并，cnt记录个数</span></span><br><span class="line"><span class="comment">3. cdq(1, n)</span></span><br><span class="line"><span class="comment">4. p[i].ans为答案</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><p>处理树上路径问题（如路径长度、路径点数等），时间复杂度 $O(n\log n)$。</p>
<p>核心思想：找树的重心作为根，统计经过根的路径，然后递归处理子树。</p>
<h3 id="树上路径统计"><a href="#树上路径统计" class="headerlink" title="树上路径统计"></a>树上路径统计</h3><p>求树上距离 $\le k$ 的点对数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+5</span>;</span><br><span class="line">vector&lt;pii&gt; g[N]; <span class="comment">// &#123;邻接点, 边权&#125;</span></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> sz[N], maxsz[N], sum;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找重心</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRoot</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>; maxsz[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getRoot</span>(v, u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        maxsz[u]=<span class="built_in">max</span>(maxsz[u], sz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxsz[u]=<span class="built_in">max</span>(maxsz[u], sum-sz[u]);</span><br><span class="line">    <span class="keyword">if</span>(maxsz[u]&lt;maxsz[root]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getDist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist.<span class="built_in">push_back</span>(d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getDist</span>(v, u, d+w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">getDist</span>(u, <span class="number">0</span>, init);</span><br><span class="line">    <span class="built_in">sort</span>(dist.<span class="built_in">begin</span>(), dist.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, r=dist.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[l]+dist[r]&lt;=k) res+=r-l, l++;</span><br><span class="line">        <span class="keyword">else</span> r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    ans+=<span class="built_in">calc</span>(u, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        ans-=<span class="built_in">calc</span>(v, w); <span class="comment">// 减去同一子树内的路径</span></span><br><span class="line">        sum=sz[v];</span><br><span class="line">        root=<span class="number">0</span>; maxsz[<span class="number">0</span>]=INT_MAX;</span><br><span class="line">        <span class="built_in">getRoot</span>(v, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">solve</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：</span></span><br><span class="line"><span class="comment">sum=n;</span></span><br><span class="line"><span class="comment">root=0; maxsz[0]=INT_MAX;</span></span><br><span class="line"><span class="comment">getRoot(1, 0);</span></span><br><span class="line"><span class="comment">solve(root);</span></span><br><span class="line"><span class="comment">cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="点分治模板（通用）"><a href="#点分治模板（通用）" class="headerlink" title="点分治模板（通用）"></a>点分治模板（通用）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, k, ans;</span><br><span class="line">vector&lt;pii&gt; g[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> sz[N], maxsz[N], root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getRoot</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> total)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sz[u]=<span class="number">1</span>; maxsz[u]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getRoot</span>(v, u, total);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        maxsz[u]=<span class="built_in">max</span>(maxsz[u], sz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxsz[u]=<span class="built_in">max</span>(maxsz[u], total-sz[u]);</span><br><span class="line">    <span class="keyword">if</span>(maxsz[u]&lt;maxsz[root]) root=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dist;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getDist</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dist.<span class="built_in">push_back</span>(d);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=fa &amp;&amp; !vis[v])</span><br><span class="line">            <span class="built_in">getDist</span>(v, u, d+w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计以u为根，经过u的路径</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 具体问题具体实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    ans+=<span class="built_in">calc</span>(u);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> [v, w]: g[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        root=<span class="number">0</span>; maxsz[<span class="number">0</span>]=INT_MAX;</span><br><span class="line">        <span class="built_in">getRoot</span>(v, <span class="number">0</span>, sz[v]);</span><br><span class="line">        <span class="built_in">divide</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pointDivide</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root=<span class="number">0</span>; maxsz[<span class="number">0</span>]=INT_MAX;</span><br><span class="line">    <span class="built_in">getRoot</span>(<span class="number">1</span>, <span class="number">0</span>, n);</span><br><span class="line">    <span class="built_in">divide</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组，可以存储不同类型的元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>&gt; Student = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">18</span>, <span class="number">213213</span>&#125;;</span><br><span class="line">cout&lt;&lt;<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(Student)&lt;&lt;endl; <span class="comment">// 输出 &quot;Bob&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>取对象中的第index个元素</strong>：<code>get&lt;index&gt;(obj)</code></p>
<p>✖ <strong>注意</strong>：这里的index只能手动输入，使用for循环这样的自动输入是不可以的</p>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>固定大小的数组，存储在栈上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 3&gt; x; <span class="comment">// 建立一个包含三个元素的数组x</span></span><br><span class="line">cout&lt;&lt;x[<span class="number">0</span>]; <span class="comment">// 使用[]随机访问</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>size()</code> / <code>empty()</code></li>
<li><code>[]</code> 随机访问</li>
<li><code>front()</code> / <code>back()</code> 获取首尾元素</li>
<li><code>fill(val)</code> 填充所有元素为val</li>
</ul>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>动态数组，最常用的容器。</p>
<p><strong>声明方式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不推荐：使用[]声明多维变长数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ver[n<span class="number">+1</span>]; <span class="comment">// ✖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐：使用嵌套方式</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">ver</span>(n<span class="number">+1</span>,<span class="number">0</span>); <span class="comment">// ✓</span></span><br><span class="line"><span class="function">vector <span class="title">dis</span><span class="params">(n<span class="number">+1</span>, vector&lt;<span class="type">int</span>&gt;(m<span class="number">+1</span>))</span></span>; <span class="comment">// 二维</span></span><br><span class="line"><span class="function">vector <span class="title">dis</span><span class="params">(m<span class="number">+1</span>, vector(n<span class="number">+1</span>, vector&lt;<span class="type">int</span>&gt;(k<span class="number">+1</span>)))</span></span>; <span class="comment">// 三维</span></span><br></pre></td></tr></table></figure>
<p><strong>常用函数</strong>：</p>
<ul>
<li><code>size()</code> / <code>empty()</code> / <code>clear()</code></li>
<li><code>resize(n)</code> 重设容器大小，但不改变已有元素的值</li>
<li><code>assign(n, val)</code> 重设容器大小为n，且替换容器内容为val</li>
<li><code>push_back(x)</code> / <code>pop_back()</code> 尾部插入/删除</li>
<li><code>front()</code> / <code>back()</code> 获取首尾元素</li>
<li><code>begin()</code> / <code>end()</code> 迭代器</li>
<li><code>[]</code> 随机访问</li>
<li><code>insert(it, x)</code> 在迭代器it处插入x</li>
<li><code>erase(it)</code> / <code>erase(first, last)</code> 删除元素</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>栈，<strong>栈顶入，栈顶出。先进后出</strong>。</p>
<ul>
<li><strong>没有clear函数</strong></li>
<li><code>size()</code> / <code>empty()</code></li>
<li><code>push(x)</code> 向栈顶插入x</li>
<li><code>top()</code> 获取栈顶元素</li>
<li><code>pop()</code> 弹出栈顶元素</li>
</ul>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><p>队列，<strong>队尾进，队头出。先进先出</strong>。</p>
<ul>
<li><strong>没有clear函数</strong>，但可以用重新构造替代：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q = <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure></li>
<li><code>size()</code> / <code>empty()</code></li>
<li><code>push(x)</code> 向队尾插入x</li>
<li><code>front()</code> / <code>back()</code> 获取队头、队尾元素</li>
<li><code>pop()</code> 弹出队头元素</li>
</ul>
<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>双向队列，两端都可以插入和删除。</p>
<ul>
<li><code>size()</code> / <code>empty()</code> / <code>clear()</code></li>
<li><code>push_front(x)</code> / <code>push_back(x)</code> 首尾插入</li>
<li><code>pop_front()</code> / <code>pop_back()</code> 首尾删除</li>
<li><code>front()</code> / <code>back()</code> 获取首尾元素</li>
<li><code>begin()</code> / <code>end()</code> 迭代器</li>
<li><code>[]</code> 随机访问</li>
</ul>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><p>优先队列，<strong>默认升序（大根堆）</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认大根堆，堆顶最大值</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>没有clear函数</strong></li>
<li><code>push(x)</code> 插入元素</li>
<li><code>top()</code> 获取堆顶元素</li>
<li><code>pop()</code> 弹出堆顶元素</li>
<li><code>size()</code> / <code>empty()</code></li>
</ul>
<p><strong>自定义排序（重载运算符）</strong>：</p>
<p>✖ <strong>注意：符号相反！！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; </span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x &gt; b.x; <span class="comment">// 想要小的在前，这里写&gt;</span></span><br><span class="line">        <span class="keyword">return</span> a.s &gt; b.s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>字符串容器。</p>
<ul>
<li><code>size()</code> / <code>empty()</code> / <code>clear()</code></li>
<li><code>push_back(c)</code> / <code>pop_back()</code> 尾部插入/删除字符</li>
<li><code>[]</code> 随机访问</li>
<li><code>substr(start, len)</code> 从start开始取长度为len的子串<ul>
<li>len省略时默认取到结尾</li>
<li>超过字符串长度时也默认取到结尾<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;S.<span class="built_in">substr</span>(<span class="number">1</span>, <span class="number">12</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>find(x)</code> / <code>rfind(x)</code> 顺序、逆序查找x，返回下标<ul>
<li>没找到时返回一个极大值</li>
<li>✖ <strong>建议与 <code>size()</code> 比较，而不要和 <code>-1</code> 比较，后者可能出错</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="string">&quot;abc&quot;</span>) &lt; s.<span class="built_in">size</span>()) <span class="comment">// ✓</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>✖ <strong>没有count函数</strong></li>
<li><code>append(str)</code> / <code>+=</code> 追加字符串</li>
<li><code>compare(str)</code> 字符串比较</li>
<li><code>replace(pos, len, str)</code> 替换子串</li>
</ul>
<h3 id="set-multiset"><a href="#set-multiset" class="headerlink" title="set / multiset"></a>set / multiset</h3><p>有序集合，<strong>默认升序，时间复杂度 $O(\log n)$</strong>。</p>
<ul>
<li><code>set</code> <strong>去重</strong></li>
<li><code>multiset</code> <strong>不去重</strong></li>
</ul>
<p><strong>常用函数</strong>：</p>
<ul>
<li><code>size()</code> / <code>empty()</code> / <code>clear()</code></li>
<li><code>insert(x)</code> 插入元素</li>
<li><code>erase(x)</code> <strong>两种删除方式</strong>：<ul>
<li>当x为某一元素时，删除所有这个数，复杂度 $O(k+\log n)$，k为删除个数</li>
<li>当x为迭代器时，删除这个迭代器，复杂度 $O(1)$</li>
</ul>
</li>
<li><code>find(x)</code> 查找元素，返回迭代器，没找到返回<code>end()</code></li>
<li><code>count(x)</code> 统计元素个数</li>
<li><code>lower_bound(x)</code> 返回 $\ge x$ 的第一个元素的迭代器</li>
<li><code>upper_bound(x)</code> 返回 $&gt; x$ 的第一个元素的迭代器</li>
<li><code>begin()</code> / <code>end()</code> 迭代器</li>
<li><code>rbegin()</code> / <code>rend()</code> 反向迭代器</li>
</ul>
<p><strong>特殊函数 next 和 prev</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">auto</span> next_it = <span class="built_in">next</span>(it); <span class="comment">// 指向5</span></span><br><span class="line"><span class="keyword">auto</span> prev_it = <span class="built_in">prev</span>(it); <span class="comment">// 指向1</span></span><br></pre></td></tr></table></figure>
<h3 id="map-multimap"><a href="#map-multimap" class="headerlink" title="map / multimap"></a>map / multimap</h3><p>键值对容器，<strong>默认按键升序，时间复杂度 $O(\log n)$</strong>，$n$ 为元素数量。</p>
<ul>
<li><code>map</code> <strong>键去重</strong></li>
<li><code>multimap</code> <strong>键不去重</strong></li>
</ul>
<p><strong>常用函数</strong>：</p>
<ul>
<li><code>size()</code> / <code>empty()</code> / <code>clear()</code></li>
<li><code>insert(&#123;key, value&#125;)</code> 插入键值对</li>
<li><code>erase(x)</code> <strong>两种删除方式</strong>：<ul>
<li>当x为某一元素时，删除所有以这个元素为下标的二元组，复杂度 $O(k+\log n)$</li>
<li>当x为迭代器时，删除这个迭代器，复杂度 $O(1)$</li>
</ul>
</li>
<li><code>find(key)</code> 查找键，返回迭代器</li>
<li><code>count(key)</code> 统计键的个数</li>
<li><code>[]</code> 访问/修改值，<strong>若键不存在会自动创建</strong></li>
<li><code>begin()</code> / <code>end()</code> 迭代器</li>
</ul>
<p>✖ <strong>慎用随机访问！</strong> 当不确定某次查询是否存在于容器中时，不要直接使用下标查询，而是先使用 <code>count()</code> 或者 <code>find()</code> 方法检查key值，防止不必要的零值二元组被构造。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法✖</span></span><br><span class="line"><span class="keyword">if</span>(mp[key]) <span class="comment">// 若key不存在，会创建mp[key]=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐做法✓</span></span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">count</span>(key)) </span><br><span class="line"><span class="keyword">if</span>(mp.<span class="built_in">find</span>(key) != mp.<span class="built_in">end</span>()) </span><br></pre></td></tr></table></figure>
<p>✖ <strong>慎用自带的 pair、tuple 作为key值类型！使用自定义结构体！</strong></p>
<h3 id="unordered-set-unordered-map"><a href="#unordered-set-unordered-map" class="headerlink" title="unordered_set / unordered_map"></a>unordered_set / unordered_map</h3><p>无序集合/映射，基于哈希表，<strong>平均时间复杂度 $O(1)$</strong>，最坏 $O(n)$。</p>
<p><strong>常用函数</strong>：与 <code>set</code> / <code>map</code> 类似，但没有 <code>lower_bound</code> / <code>upper_bound</code>。</p>
<ul>
<li><code>size()</code> / <code>empty()</code> / <code>clear()</code></li>
<li><code>insert(x)</code> / <code>erase(x)</code> / <code>find(x)</code> / <code>count(x)</code></li>
<li><code>[]</code> (仅unordered_map)</li>
</ul>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><p>位集，将数据转换为二进制，从高位到低位排序，以 $0$ 为最低位。当位数相同时支持全部的位运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;10&gt; bs; <span class="comment">// 10位bitset</span></span><br><span class="line"><span class="function">bitset&lt;10&gt; <span class="title">bs</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 二进制 0000000101</span></span><br><span class="line"><span class="function">bitset&lt;10&gt; <span class="title">bs</span><span class="params">(<span class="string">&quot;1010&quot;</span>)</span></span>; <span class="comment">// 二进制 0000001010</span></span><br></pre></td></tr></table></figure>
<p><strong>常用函数</strong>：</p>
<ul>
<li>✖ <strong>没有clear函数</strong></li>
<li><code>size()</code> / <code>empty()</code></li>
<li><code>count()</code> 统计1的个数</li>
<li><code>any()</code> 是否有1</li>
<li><code>none()</code> 是否全为0</li>
<li><code>all()</code> 是否全为1</li>
<li><code>set()</code> 全部置1</li>
<li><code>set(pos)</code> 将pos位置1</li>
<li><code>set(pos, val)</code> 将pos位设为val</li>
<li><code>reset()</code> 全部置0</li>
<li><code>reset(pos)</code> 将pos位置0</li>
<li><code>flip()</code> 全部翻转</li>
<li><code>flip(pos)</code> 翻转pos位</li>
<li><code>test(pos)</code> 返回pos位的值</li>
<li><code>[]</code> 访问某一位</li>
<li><code>to_string()</code> 转换为字符串</li>
<li><code>to_ulong()</code> / <code>to_ullong()</code> 转换为整数</li>
</ul>
<p><strong>位运算</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;4&gt; <span class="title">bs1</span><span class="params">(<span class="string">&quot;1010&quot;</span>)</span>, <span class="title">bs2</span><span class="params">(<span class="string">&quot;1100&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; (bs1 &amp; bs2); <span class="comment">// 1000 与</span></span><br><span class="line">cout &lt;&lt; (bs1 | bs2); <span class="comment">// 1110 或</span></span><br><span class="line">cout &lt;&lt; (bs1 ^ bs2); <span class="comment">// 0110 异或</span></span><br><span class="line">cout &lt;&lt; (~bs1);      <span class="comment">// 0101 取反</span></span><br><span class="line">cout &lt;&lt; (bs1 &lt;&lt; <span class="number">1</span>);  <span class="comment">// 0100 左移</span></span><br><span class="line">cout &lt;&lt; (bs1 &gt;&gt; <span class="number">1</span>);  <span class="comment">// 0101 右移</span></span><br></pre></td></tr></table></figure>
<h2 id="常用算法函数"><a href="#常用算法函数" class="headerlink" title="常用算法函数"></a>常用算法函数</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>排序，时间复杂度 $O(n\log n)$。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(a, a+n); <span class="comment">// 数组排序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">// vector排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义比较函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h3><p>反转容器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(a, a+n);</span><br><span class="line"><span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><p>去重（需要先排序），返回去重后的尾迭代器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">v.<span class="built_in">erase</span>(<span class="built_in">unique</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound / upper_bound"></a>lower_bound / upper_bound</h3><p>二分查找（需要有序）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lower_bound: 返回 &gt;= x 的第一个位置（迭代器）</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// upper_bound: 返回 &gt; x 的第一个位置（迭代器）</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">upper_bound</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="type">int</span> pos = <span class="built_in">lower_bound</span>(a, a+n, x) - a;</span><br></pre></td></tr></table></figure>
<h3 id="min-max-swap"><a href="#min-max-swap" class="headerlink" title="min / max / swap"></a>min / max / swap</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(a, b);</span><br><span class="line"><span class="type">int</span> mx = <span class="built_in">max</span>(a, b);</span><br><span class="line"><span class="type">int</span> mn = <span class="built_in">min</span>(&#123;a, b, c&#125;); </span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br></pre></td></tr></table></figure>
<h3 id="next-permutation-prev-permutation"><a href="#next-permutation-prev-permutation" class="headerlink" title="next_permutation / prev_permutation"></a>next_permutation / prev_permutation</h3><p>全排列</p>
<p><code>next_permutation</code>是生成下一个排列，即字典序中下一个比当前排列大的排列（升序-&gt;降序）<br><code>prev_permutation</code>是生成上一个排列，即字典序中上一个比当前排列小的排列（降序-&gt;升序）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 处理当前排列</span></span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="built_in">next_permutation</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure>
<h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><p>求和，需要 <code>#include &lt;numeric&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">ll sum = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0LL</span>); <span class="comment">// 注意初始值类型</span></span><br></pre></td></tr></table></figure>
<h3 id="fill-memset"><a href="#fill-memset" class="headerlink" title="fill / memset"></a>fill / memset</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(a, a+n, <span class="number">0</span>); <span class="comment">// 任意值</span></span><br><span class="line"><span class="built_in">fill</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a)); <span class="comment">// 只能用于0和-1</span></span><br></pre></td></tr></table></figure>
<h3 id="to-string-stoi-stoll"><a href="#to-string-stoi-stoll" class="headerlink" title="to_string / stoi / stoll"></a>to_string / stoi / stoll</h3><p>字符串和数字之间的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字转字符串</span></span><br><span class="line">string s = <span class="built_in">to_string</span>(<span class="number">123</span>);</span><br><span class="line">string s2 = <span class="built_in">to_string</span>(<span class="number">3.14</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转整数</span></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">stoi</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b = <span class="built_in">stoll</span>(<span class="string">&quot;123456789012345&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持不同进制</span></span><br><span class="line"><span class="type">int</span> hex = <span class="built_in">stoi</span>(<span class="string">&quot;1A&quot;</span>, <span class="literal">nullptr</span>, <span class="number">16</span>); <span class="comment">// 26</span></span><br><span class="line"><span class="type">int</span> bin = <span class="built_in">stoi</span>(<span class="string">&quot;1010&quot;</span>, <span class="literal">nullptr</span>, <span class="number">2</span>); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：stoi会忽略前导空格，遇到非数字字符停止</span></span><br><span class="line"><span class="type">int</span> c = <span class="built_in">stoi</span>(<span class="string">&quot;  123abc&quot;</span>); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><code>stoi</code>是转换为<code>i32</code>，<code>stoll</code>是转换为<code>i64</code></li>
<li>超出范围会抛出 <code>out_of_range</code> 异常</li>
<li>格式错误会抛出 <code>invalid_argument</code> 异常</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.teslongxiao.cn">Meta Xiao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.teslongxiao.cn/posts/3538e23e.html">https://www.teslongxiao.cn/posts/3538e23e.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.teslongxiao.cn" target="_blank">浮生若梦</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-share"><div class="social-share" data-image="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/icpc-logo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/45c6e9dc.html" title="STL库笔记"><img class="cover" src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/sakuragirl.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-15</div><div class="info-item-2">STL库笔记</div></div><div class="info-2"><div class="info-item-1">前言 Pigmaei gigantum humeris impositi plusquam ipsi gigantes vident (If I have seen further it is by standing on the shoulders of Giants.) —Isaac...</div></div></div></a><a class="pagination-related" href="/posts/6ecdd18f.html" title="WZU ACM集训队10.25训练D题补"><img class="cover" src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Konachan.com%20-%20367161%20sample.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-27</div><div class="info-item-2">WZU ACM集训队10.25训练D题补</div></div><div class="info-2"><div class="info-item-1">题目大意定义函数 $f(n)$ 为：  f(n)=\left\{\begin{matrix}  1 \ ,& if \ n = 0\\ f(n\pmod{10})^{f(n/10)} \ , &else. \end{matrix}\right.特别地 $0^0=1$  求对于 $n\in[2,1e9]$ 的 $f(n)\mod m$    思路对于题目的函数 $f(n)$，我们假设一个多位十进制数 (a_n a_{n-1} \cdots a_1 a_0)_{10} 那么对于该函数可以递归成以下形式：  f(n)= a_0^{a_1^{a_2^\cdots}} \mod m \tag{*}即求 $(*)$ 式的结果。 首先我们马上会想到用快速幂和记忆化存储 f(n)的值，但是这样递归很容易溢出，即使大数模拟也会超时，我们下面考虑如何用数论化简。 欧拉定理欧拉定理指出，对于整数 $m\gt0$ 和整数 $a$ ，且 $\mathbf{gcd}(a,m)=1$ ，有：  a^{\varphi(m)}\equiv 1 \pmod m下面我们给出该定理的应用，考虑这个数 $a^b\mod...</div></div></div></a><a class="pagination-related" href="/posts/bb2feb5d.html" title="abc422 my editorial"><img class="cover" src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Yanami_Anna.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-08</div><div class="info-item-2">abc422 my editorial</div></div><div class="info-2"><div class="info-item-1">这次的abc打的很愉快，记录下。 传送门-&gt;abc422 AA题就是输入输出题，直接模拟即可。 12345678910111213141516171819202122#pragma GCC optimize(&quot;O2&quot;)#pragma GCC optimize(&quot;O3&quot;)#pragma GCC optimize(&quot;Ofast&quot;)#pragma GCC optimize(&quot;unroll-loops&quot;)#include &lt;bits/stdc++.h&gt;using namespace std;#define endl &#x27;\n&#x27;int a,b;char c;int main()&#123;	ios::sync_with_stdio(false);	cin.tie(0);	cout.tie(0);	cin &gt;&gt; a &gt;&gt; c &gt;&gt; b;	if(b==8)cout &lt;&lt; a+1 &lt;&lt; c &lt;&lt;...</div></div></div></a><a class="pagination-related" href="/posts/623e9466.html" title="数据结构笔记--目录"><img class="cover" src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Frieren.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-28</div><div class="info-item-2">数据结构笔记--目录</div></div><div class="info-2"><div class="info-item-1"> .ds-unified-container {   --ds-light-bg: rgba(255, 255, 255, 0.8);   --ds-light-shadow: 0 5px 6px -5px rgba(133, 133, 133, 0.6);   --ds-dark-bg: rgba(24, 24, 30, 0.5);   --ds-accent: #7F5AF0;   --ds-accent-hover: #6C4BD3;   --ds-text-light: #2D3748;   --ds-text-dark: #EDF2F7; }  /* 基础样式 */ .ds-unified-list {   border-radius: 12px;   padding: 1.5rem;   backdrop-filter: blur(7px);   transition: all 0.3s ease; }  /* 明亮模式 */ .ds-unified-list {   background: var(--ds-light-bg);   box-shadow:...</div></div></div></a><a class="pagination-related" href="/posts/928debf2.html" title="数据结构笔记--导论"><img class="cover" src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Frieren.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-02</div><div class="info-item-2">数据结构笔记--导论</div></div><div class="info-2"><div class="info-item-1">系列文章目录：  数据结构—导论 数据结构—算法基础 数据结构—线性表 数据结构—树 数据结构—并查集、哈希表、堆 数据结构—图   数据结构的基本知识和导论 数据结构是计算机存储、组织数据的方式，数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。  Nikolaus Wirth 在其著作《Algorithms + Data Structures =...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%B4%E3%80%81%E7%BC%96%E8%AF%91%E3%80%81debug"><span class="toc-number">2.</span> <span class="toc-text">头、编译、debug</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4"><span class="toc-number">2.1.</span> <span class="toc-text">头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">编译运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B8%B8%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">一些常量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%A2%84%E4%BC%B0"><span class="toc-number">4.</span> <span class="toc-text">时间复杂度预估</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.</span> <span class="toc-text">数据结构模板</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%8B%9F"><span class="toc-number">5.1.</span> <span class="toc-text">大数高精度模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.1.</span> <span class="toc-text">手写结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E8%87%AA%E5%B8%A6"><span class="toc-number">5.1.2.</span> <span class="toc-text">语言自带</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">5.2.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">5.3.</span> <span class="toc-text">字符串哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%80%BChash"><span class="toc-number">5.3.1.</span> <span class="toc-text">双值hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2hash%E5%8C%B9%E9%85%8D"><span class="toc-number">5.3.2.</span> <span class="toc-text">子串hash匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">5.4.</span> <span class="toc-text">二叉堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ST%E8%A1%A8"><span class="toc-number">5.6.</span> <span class="toc-text">ST表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">5.7.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8C%BA%E9%97%B4%E5%92%8C-%E6%87%92%E6%A0%87%E8%AE%B0"><span class="toc-number">5.7.1.</span> <span class="toc-text">基础区间和+懒标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">5.7.2.</span> <span class="toc-text">动态开点线段树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">5.8.</span> <span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%B7%A6%E8%BE%B9%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%AE%83%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">5.8.1.</span> <span class="toc-text">求左边第一个比它小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF%EF%BC%88%E6%9F%B1%E7%8A%B6%E5%9B%BE%EF%BC%89"><span class="toc-number">5.8.2.</span> <span class="toc-text">最大矩形面积（柱状图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">5.9.</span> <span class="toc-text">单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">5.9.1.</span> <span class="toc-text">滑动窗口最大值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP"><span class="toc-number">5.9.2.</span> <span class="toc-text">单调队列优化DP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">5.10.</span> <span class="toc-text">树链剖分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%88%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%89"><span class="toc-number">5.11.</span> <span class="toc-text">主席树（可持久化线段树）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F"><span class="toc-number">5.11.1.</span> <span class="toc-text">区间第k小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E7%AE%97%E6%B3%95"><span class="toc-number">5.12.</span> <span class="toc-text">分块算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E5%8A%A0%E3%80%81%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2%E5%92%8C"><span class="toc-number">5.12.1.</span> <span class="toc-text">区间加、区间查询和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%A0%91%EF%BC%88Treap%EF%BC%89"><span class="toc-number">5.13.</span> <span class="toc-text">平衡树（Treap）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">算法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">6.1.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">二分查找（浮点数）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">6.3.</span> <span class="toc-text">三分查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E3%80%81%E5%87%A0%E4%BD%95%E3%80%81%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">7.</span> <span class="toc-text">数论、几何、多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F-%E7%BB%93%E8%AE%BA"><span class="toc-number">7.1.</span> <span class="toc-text">常用公式&#x2F;结论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3%E7%9B%B8%E5%85%B3"><span class="toc-number">7.1.1.</span> <span class="toc-text">质因数分解相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86"><span class="toc-number">7.1.2.</span> <span class="toc-text">基本定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.3.</span> <span class="toc-text">欧拉函数性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.4.</span> <span class="toc-text">莫比乌斯函数性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%BD%99%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.5.</span> <span class="toc-text">同余性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E6%80%A7%E8%B4%A8"><span class="toc-number">7.1.6.</span> <span class="toc-text">组合数性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%BB%93%E8%AE%BA"><span class="toc-number">7.1.7.</span> <span class="toc-text">其他常用结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">7.2.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">7.3.</span> <span class="toc-text">矩阵快速幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97"><span class="toc-number">7.4.</span> <span class="toc-text">扩展欧几里得</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83"><span class="toc-number">7.5.</span> <span class="toc-text">乘法逆元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83%EF%BC%88%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86%EF%BC%89"><span class="toc-number">7.5.1.</span> <span class="toc-text">快速幂求逆元（费马小定理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%B1%82%E9%80%86%E5%85%83"><span class="toc-number">7.5.2.</span> <span class="toc-text">扩展欧几里得求逆元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%B1%82%E9%80%86%E5%85%83"><span class="toc-number">7.5.3.</span> <span class="toc-text">线性求逆元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="toc-number">7.6.</span> <span class="toc-text">中国剩余定理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%95%B0%E4%B8%A4%E4%B8%A4%E4%BA%92%E8%B4%A8"><span class="toc-number">7.6.1.</span> <span class="toc-text">模数两两互质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%95%B0%E4%B8%8D%E4%B8%A4%E4%B8%A4%E4%BA%92%E8%B4%A8"><span class="toc-number">7.6.2.</span> <span class="toc-text">模数不两两互质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3"><span class="toc-number">7.7.</span> <span class="toc-text">质因数分解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="toc-number">7.7.1.</span> <span class="toc-text">基本方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%96%B9%E6%B3%95"><span class="toc-number">7.7.2.</span> <span class="toc-text">快速方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pollard%E2%80%99s-Rho-%E7%AE%97%E6%B3%95%EF%BC%88%E5%A4%A7%E6%95%B0%E5%88%86%E8%A7%A3%EF%BC%89"><span class="toc-number">7.7.3.</span> <span class="toc-text">Pollard’s Rho 算法（大数分解）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%AD%9B%E8%B4%A8%E6%95%B0%E3%80%81%E6%AC%A7%E6%8B%89%E3%80%81%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF"><span class="toc-number">7.8.</span> <span class="toc-text">线筛质数、欧拉、莫比乌斯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="toc-number">7.9.</span> <span class="toc-text">欧拉函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%95%B0"><span class="toc-number">7.9.1.</span> <span class="toc-text">单个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F"><span class="toc-number">7.9.2.</span> <span class="toc-text">批量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%87%BD%E6%95%B0"><span class="toc-number">7.10.</span> <span class="toc-text">莫比乌斯函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E6%95%B0-1"><span class="toc-number">7.10.1.</span> <span class="toc-text">单个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F-1"><span class="toc-number">7.10.2.</span> <span class="toc-text">批量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">7.11.</span> <span class="toc-text">快速组合数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">7.11.1.</span> <span class="toc-text">预处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86"><span class="toc-number">7.11.2.</span> <span class="toc-text">卢卡斯定理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E9%99%8D%E5%B9%82"><span class="toc-number">7.12.</span> <span class="toc-text">欧拉降幂</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E6%9D%BF"><span class="toc-number">7.12.1.</span> <span class="toc-text">通用模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%82%E5%A1%94%E9%97%AE%E9%A2%98%EF%BC%88%E6%89%A9%E5%B1%95%EF%BC%89"><span class="toc-number">7.12.2.</span> <span class="toc-text">幂塔问题（扩展）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="toc-number">7.13.</span> <span class="toc-text">高斯消元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%89%88%E6%9C%AC"><span class="toc-number">7.13.1.</span> <span class="toc-text">浮点数版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%89%88%E6%9C%AC%EF%BC%88%E6%A8%A1%E6%84%8F%E4%B9%89%EF%BC%89"><span class="toc-number">7.13.2.</span> <span class="toc-text">整数版本（模意义）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-number">7.13.3.</span> <span class="toc-text">求行列式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="toc-number">7.14.</span> <span class="toc-text">线性基</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.14.1.</span> <span class="toc-text">基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%AC%ACk%E5%B0%8F%E5%BC%82%E6%88%96%E5%92%8C"><span class="toc-number">7.14.2.</span> <span class="toc-text">查询第k小异或和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E7%BA%BF%E6%80%A7%E5%9F%BA"><span class="toc-number">7.14.3.</span> <span class="toc-text">合并两个线性基</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%8C%BA%E9%97%B4%E5%BC%82%E6%88%96%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">7.14.4.</span> <span class="toc-text">例子：区间异或最大值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95"><span class="toc-number">7.15.</span> <span class="toc-text">平面几何</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E4%BD%93%E5%87%A0%E4%BD%95"><span class="toc-number">7.16.</span> <span class="toc-text">立体几何</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%B8%E5%8C%85%E7%AE%97%E6%B3%95"><span class="toc-number">7.17.</span> <span class="toc-text">凸包算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0"><span class="toc-number">7.18.</span> <span class="toc-text">生成函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%EF%BC%88OGF%EF%BC%89"><span class="toc-number">7.18.1.</span> <span class="toc-text">普通生成函数（OGF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%EF%BC%88EGF%EF%BC%89"><span class="toc-number">7.18.2.</span> <span class="toc-text">指数生成函数（EGF）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">7.18.3.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%EF%BC%88%E5%A4%9A%E9%A1%B9%E5%BC%8F%E8%BF%90%E7%AE%97%EF%BC%89"><span class="toc-number">7.18.4.</span> <span class="toc-text">代码（多项式运算）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%EF%BC%88FFT%EF%BC%89"><span class="toc-number">7.19.</span> <span class="toc-text">快速傅里叶变换（FFT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E5%8F%98%E6%8D%A2%EF%BC%88NTT%EF%BC%89"><span class="toc-number">7.20.</span> <span class="toc-text">数论变换（NTT）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">8.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">8.1.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">8.2.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.1.</span> <span class="toc-text">Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">Bellman-Ford算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPFA%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">SPFA算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd-Warshall-%E7%AE%97%E6%B3%95"><span class="toc-number">8.2.4.</span> <span class="toc-text">Floyd-Warshall 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88MST%EF%BC%89"><span class="toc-number">8.3.</span> <span class="toc-text">最小生成树（MST）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.1.</span> <span class="toc-text">Kruskal算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">8.3.2.</span> <span class="toc-text">Prim算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F-SCC"><span class="toc-number">8.4.</span> <span class="toc-text">强连通分量(SCC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kosaraju%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.1.</span> <span class="toc-text">Kosaraju算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tarjan%E7%AE%97%E6%B3%95"><span class="toc-number">8.4.2.</span> <span class="toc-text">Tarjan算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84"><span class="toc-number">8.5.</span> <span class="toc-text">欧拉回路&#x2F;欧拉路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hierholzer%E7%AE%97%E6%B3%95%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">8.5.1.</span> <span class="toc-text">Hierholzer算法（无向图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hierholzer%E7%AE%97%E6%B3%95%EF%BC%88%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">8.5.2.</span> <span class="toc-text">Hierholzer算法（有向图）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SAT"><span class="toc-number">8.6.</span> <span class="toc-text">2-SAT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F"><span class="toc-number">8.7.</span> <span class="toc-text">差分约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E5%A4%A7%E5%80%BC%EF%BC%88%E7%94%A8%E6%9C%80%E7%9F%AD%E8%B7%AF%EF%BC%89"><span class="toc-number">8.7.1.</span> <span class="toc-text">求最大值（用最短路）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%88%E7%94%A8%E6%9C%80%E9%95%BF%E8%B7%AF%EF%BC%89"><span class="toc-number">8.7.2.</span> <span class="toc-text">求最小值（用最长路）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%BC%A9%E7%82%B9"><span class="toc-number">8.8.</span> <span class="toc-text">有向图缩点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">8.9.</span> <span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kuhn-Munkres%E7%AE%97%E6%B3%95"><span class="toc-number">8.9.1.</span> <span class="toc-text">Kuhn-Munkres算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hopcroft-Karp%E7%AE%97%E6%B3%95"><span class="toc-number">8.9.2.</span> <span class="toc-text">Hopcroft-Karp算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E5%88%A4%E5%AE%9A"><span class="toc-number">8.9.3.</span> <span class="toc-text">二分图判定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-number">8.10.</span> <span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dinic%E7%AE%97%E6%B3%95"><span class="toc-number">8.10.1.</span> <span class="toc-text">Dinic算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E6%A8%A1%E6%8A%80%E5%B7%A7"><span class="toc-number">8.10.2.</span> <span class="toc-text">建模技巧</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">8.11.</span> <span class="toc-text">最小费用最大流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%B2%E7%82%B9%E5%92%8C%E6%A1%A5%EF%BC%88Tarjan%EF%BC%89"><span class="toc-number">8.12.</span> <span class="toc-text">割点和桥（Tarjan）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">9.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">9.1.</span> <span class="toc-text">树的直径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%8D%E5%A2%9ELCA"><span class="toc-number">9.2.</span> <span class="toc-text">倍增LCA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tarjan%E7%AE%97%E6%B3%95%EF%BC%88%E7%A6%BB%E7%BA%BF%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">Tarjan算法（离线）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">10.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP"><span class="toc-number">10.1.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Z-Algorithm"><span class="toc-number">10.2.</span> <span class="toc-text">Z-Algorithm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Trie%E6%A0%91%EF%BC%88%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%89"><span class="toc-number">10.3.</span> <span class="toc-text">Trie树（字典树）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Manacher%E7%AE%97%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">Manacher算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AC%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="toc-number">10.5.</span> <span class="toc-text">AC自动机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84"><span class="toc-number">10.6.</span> <span class="toc-text">后缀数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2"><span class="toc-number">10.6.1.</span> <span class="toc-text">应用：最长重复子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E4%B8%8D%E5%90%8C%E5%AD%90%E4%B8%B2%E4%B8%AA%E6%95%B0"><span class="toc-number">10.6.2.</span> <span class="toc-text">应用：不同子串个数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">11.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1%E8%83%8C%E5%8C%85"><span class="toc-number">11.1.1.</span> <span class="toc-text">0&#x2F;1背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">11.1.2.</span> <span class="toc-text">完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">11.1.3.</span> <span class="toc-text">多重背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E8%83%8C%E5%8C%85"><span class="toc-number">11.1.4.</span> <span class="toc-text">混合背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E8%83%8C%E5%8C%85"><span class="toc-number">11.1.5.</span> <span class="toc-text">二维背包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LIS%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">最长上升子序列（LIS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88LCS%EF%BC%89"><span class="toc-number">11.3.</span> <span class="toc-text">最长公共子序列（LCS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9DP"><span class="toc-number">11.4.</span> <span class="toc-text">状态压缩DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%EF%BC%88TSP%EF%BC%89"><span class="toc-number">11.4.1.</span> <span class="toc-text">旅行商问题（TSP）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E6%9E%9A%E4%B8%BE"><span class="toc-number">11.4.2.</span> <span class="toc-text">子集枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E5%8E%8BDP-%E6%A3%8B%E7%9B%98%E6%94%BE%E7%BD%AE"><span class="toc-number">11.4.3.</span> <span class="toc-text">状压DP - 棋盘放置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E4%BD%8DDP"><span class="toc-number">11.5.</span> <span class="toc-text">数位DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%EF%BC%9A%E4%B8%8D%E5%90%AB%E8%BF%9E%E7%BB%AD49%E7%9A%84%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">11.5.1.</span> <span class="toc-text">例：不含连续49的数的个数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2DP"><span class="toc-number">11.6.</span> <span class="toc-text">树形DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86"><span class="toc-number">11.6.1.</span> <span class="toc-text">树的最大独立集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E8%83%8C%E5%8C%85"><span class="toc-number">11.6.2.</span> <span class="toc-text">树上背包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4DP"><span class="toc-number">11.7.</span> <span class="toc-text">区间DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">11.7.1.</span> <span class="toc-text">石子合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-number">11.7.2.</span> <span class="toc-text">环形石子合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%BB%8F%E5%85%B8DP"><span class="toc-number">11.8.</span> <span class="toc-text">其他经典DP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%EF%BC%88Kadane%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">11.8.1.</span> <span class="toc-text">最大子段和（Kadane算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C"><span class="toc-number">11.8.2.</span> <span class="toc-text">最大子矩阵和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">11.8.3.</span> <span class="toc-text">编辑距离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7"><span class="toc-number">12.</span> <span class="toc-text">优化技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">12.1.</span> <span class="toc-text">离散化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">12.1.1.</span> <span class="toc-text">区间离散化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">莫队算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E8%8E%AB%E9%98%9F"><span class="toc-number">12.2.1.</span> <span class="toc-text">普通莫队</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E4%BF%AE%E6%94%B9%E8%8E%AB%E9%98%9F"><span class="toc-number">12.2.2.</span> <span class="toc-text">带修改莫队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CDQ%E5%88%86%E6%B2%BB"><span class="toc-number">12.3.</span> <span class="toc-text">CDQ分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%BB%B4%E5%81%8F%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">12.3.1.</span> <span class="toc-text">三维偏序问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB"><span class="toc-number">12.4.</span> <span class="toc-text">点分治</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E8%B7%AF%E5%BE%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">12.4.1.</span> <span class="toc-text">树上路径统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%88%86%E6%B2%BB%E6%A8%A1%E6%9D%BF%EF%BC%88%E9%80%9A%E7%94%A8%EF%BC%89"><span class="toc-number">12.4.2.</span> <span class="toc-text">点分治模板（通用）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">13.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">13.1.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple"><span class="toc-number">13.1.1.</span> <span class="toc-text">tuple</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array"><span class="toc-number">13.1.2.</span> <span class="toc-text">array</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">13.1.3.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stack"><span class="toc-number">13.1.4.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#queue"><span class="toc-number">13.1.5.</span> <span class="toc-text">queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deque"><span class="toc-number">13.1.6.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#priority-queue"><span class="toc-number">13.1.7.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string"><span class="toc-number">13.1.8.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-multiset"><span class="toc-number">13.1.9.</span> <span class="toc-text">set &#x2F; multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map-multimap"><span class="toc-number">13.1.10.</span> <span class="toc-text">map &#x2F; multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unordered-set-unordered-map"><span class="toc-number">13.1.11.</span> <span class="toc-text">unordered_set &#x2F; unordered_map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitset"><span class="toc-number">13.1.12.</span> <span class="toc-text">bitset</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">常用算法函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">13.2.1.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverse"><span class="toc-number">13.2.2.</span> <span class="toc-text">reverse</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique"><span class="toc-number">13.2.3.</span> <span class="toc-text">unique</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lower-bound-upper-bound"><span class="toc-number">13.2.4.</span> <span class="toc-text">lower_bound &#x2F; upper_bound</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#min-max-swap"><span class="toc-number">13.2.5.</span> <span class="toc-text">min &#x2F; max &#x2F; swap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-permutation-prev-permutation"><span class="toc-number">13.2.6.</span> <span class="toc-text">next_permutation &#x2F; prev_permutation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accumulate"><span class="toc-number">13.2.7.</span> <span class="toc-text">accumulate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fill-memset"><span class="toc-number">13.2.8.</span> <span class="toc-text">fill &#x2F; memset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#to-string-stoi-stoll"><span class="toc-number">13.2.9.</span> <span class="toc-text">to_string &#x2F; stoi &#x2F; stoll</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/ee1dab94.html" title="概率论与数理统计期末复习">概率论与数理统计期末复习</a><time datetime="2026-01-17T12:43:34.000Z" title="发表于 2026-01-17 20:43:34">2026-01-17</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><footer id="footer" style="background: transparent"><div id="footer_icons"><div><a class="icon_link" target="_blank" rel="noopener external nofollow" href="https://www.teslongxiao.cn/about" title="关于我"><i class="fa-solid fa-compass"></i></a><a class="icon_link" target="_blank" rel="noopener external nofollow" href="https://res.abeim.cn/api/qq/?qq=2040426884" title="联系QQ"><i class="fa-brands fa-qq"></i></a><a class="icon_link" target="_blank" rel="noopener external nofollow" href="mailto:2040426884@qq.com" title="发送邮件"><i class="fa-solid fa-envelope"></i></a></div><img class="footer_logo" src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/aoao.gif" onclick="btf.scrollToDest(0,500)" title="返回顶部"/><div><a class="icon_link" target="_blank" rel="noopener external nofollow" href="https://github.com/META-Xiao" title="Github主页"><i class="fa-brands fa-github"></i></a><a class="icon_link" target="_blank" rel="noopener external nofollow" href="https://space.bilibili.com/332124713" title="哔哩哔哩主页"><i class="fa-brands fa-bilibili"></i></a><a class="icon_link" href="/message/" title="留言"><i class="fa-solid fa-comment"></i></a></div><div id="footer_content"><div class="footer-group"><h3 class="footer-title"></h3><div class="footer-links"><a class="footer-item" href="undefined"></a></div></div></div></div><div id="footer-bottom"><div class="footer-bottom-content"><div class="footer-bottom-left"><span class="copyright">&copy;2024 - 2026 By <a target="_blank" rel="noopener" href="https://www.teslongxiao.cn" title="点击访问&quot;Meta&quot;的主页" style="margin-left:5px">Meta</a></span><div><a class="footer-bottom-link" target="_blank" href="https://icp.gov.moe/?keyword=20250061" rel="noopener external nofollow" title="萌ICP备20250061号">萌ICP备20250061号</a><a class="footer-bottom-link" target="_blank" href="https://v6.51.la/report/overview?comId=510796" rel="noopener external nofollow" title="51LA">统计信息</a></div></div><div class="footer-bottom-right"><div id="runtime" title="已运行时长">本站已运行：0 天 0 时 0 分 0 秒</div><div><a class="footer-bottom-link" target="_blank" href="https://hexo.io/zh-cn/" rel="noopener external nofollow" title="框架">Hexo</a><a class="footer-bottom-link" target="_blank" href="https://butterfly.js.org/" rel="noopener external nofollow" title="主题">Butterfly</a></div><script type="js" src="/js/footer.js"> </script></div></div></div></footer></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到底部"><span class="scroll-percent"></span><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = {"data-mapping":"pathname","data-strict":1,"data-reactions-enabled":1,"data-emit-metadata":0,"data-input-position":"top","data-lang":"zh-CN"}

  const getGiscusTheme = theme => theme === 'dark' ? 'dark_dimmed' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'META-Xiao/blog-comments',
      'data-repo-id': 'R_kgDOQAXbjw',
      'data-category-id': 'DIC_kwDOQAXbj84CwgFy',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3L3LMrlEa92UPmXV",ck:"3L3LMrlEa92UPmXV"})</script><script defer src="/js/footer.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["link[rel=\"canonical\"]","meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"]):not([href="/posts/257e1115.html"]):not([href="/posts/928debf2.html"]):not([href="/posts/49f4a0d6.html"]):not([href="/posts/dec5d03c.html"]):not([href="/posts/b05b7d2d.html"]):not([href="/posts/5e8d613b.html"]):not([href="/posts/39efaf90.html"]):not([href="/project/"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
      <script data-pjax>
        if (typeof window.recommend === 'undefined') {
          window.recommend = {
            hexo_butterfly_recommend_init: function() {
              const $recommend = document.querySelector('#recommend');
              if($recommend) return;
              document.documentElement.style.setProperty('--recommend-main', '#409eff');
              document.documentElement.style.setProperty('--recommend-deep', '#0075ffdd');
              const hexo_butterfly_recommend_elist = 'null'.split(',');
              var hexo_butterfly_recommend_cpage = location.pathname;
              const hexo_butterfly_recommend_epage = '/';
              var hexo_butterfly_recommend_flag = 0;
        
              for (var i = 0; i < hexo_butterfly_recommend_elist.length; i++) {
                if (hexo_butterfly_recommend_cpage.includes(hexo_butterfly_recommend_elist[i])) {
                  hexo_butterfly_recommend_flag++;
                }
              }
              if ((hexo_butterfly_recommend_epage === 'all') && (hexo_butterfly_recommend_flag === 0)) {
                window.recommend.hexo_butterfly_recommend_injector_config();
              } else if (hexo_butterfly_recommend_epage === hexo_butterfly_recommend_cpage) {
                window.recommend.hexo_butterfly_recommend_injector_config();
              }
            },
            hexo_butterfly_recommend_injector_config: function() {
              var parent_div_git = document.getElementById('content-inner');
              var item_html = '<div class="recommend-right" id="recommend"><div id="recommend-content" onmousewheel="recommend.postScroll(this)"><div class="recommend-wrapper" id="recommend-banner"><div id="recommend-banner-wrapper"><div class="recommend-banner-title-wrapper"><div class="recommend-banner-title">Stay hungry</div><div class="recommend-banner-title">Stay foolish</div><div class="recommend-banner-title">www.teslongxiao.cn</div></div><div class="recommend-tags-all"><div class="recommend-tags-wrapper"><div class="recommend-tags-line"><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #e9572b"><i class="fa-brands fa-html5" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #ca6496"><i class="fa-brands fa-sass" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #f7cb4f"><i class="fa-brands fa-js" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #bd0102"><i class="fa-brands fa-angular" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #df5b40"><i class="fa-brands fa-git-alt" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #e9572b"><i class="fa-brands fa-html5" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #ca6496"><i class="fa-brands fa-sass" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #f7cb4f"><i class="fa-brands fa-js" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #bd0102"><i class="fa-brands fa-angular" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #df5b40"><i class="fa-brands fa-git-alt" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #e9572b"><i class="fa-brands fa-html5" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #ca6496"><i class="fa-brands fa-sass" style="color: #fff"></i></div></div></div><div class="recommend-tags-line"><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #2c51db"><i class="fa-brands fa-css3-alt" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #563e7c"><i class="fa-brands fa-bootstrap" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #42b883"><i class="fa-brands fa-vuejs" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #37322e"><i class="fa-brands fa-node" style="color: #7dbd05"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #2c51db"><i class="fa-brands fa-css3-alt" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #563e7c"><i class="fa-brands fa-bootstrap" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #42b883"><i class="fa-brands fa-vuejs" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #37322e"><i class="fa-brands fa-node" style="color: #7dbd05"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #2c51db"><i class="fa-brands fa-css3-alt" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #563e7c"><i class="fa-brands fa-bootstrap" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #42b883"><i class="fa-brands fa-vuejs" style="color: #fff"></i></div></div><div class="recommend-tags-column"><div class="recommend-tags-icon" style="background: #37322e"><i class="fa-brands fa-node" style="color: #7dbd05"></i></div></div></div></div></div><a id="recommend-banner-hover" onclick="recommend.toRandomPost()"><span class="recommend-banner-text">随便逛逛</span><i class="fas fa-arrow-right recommend-banner-righticon"></i></a></div><div id="recommend-category"><div class="recommend-categoryItem"><a class="recommend-categoryItem-button" onclick="recommend.toPost(&quot;categories/精选&quot;)"><div class="recommend-categoryItem-bg" style="background: linear-gradient(to right, #358bff, #15c6ff)"></div><span class="recommend-categoryItem-text">站长精选</span><i class="fa-solid fa-star"></i></a></div><div class="recommend-categoryItem"><a class="recommend-categoryItem-button" onclick="recommend.toPost(&quot;categories&quot;)"><div class="recommend-categoryItem-bg" style="background: linear-gradient(to right, #f65, #ffbf37)"></div><span class="recommend-categoryItem-text">文章分类</span><i class="fa-solid fa-book"></i></a></div><div class="recommend-categoryItem"><a class="recommend-categoryItem-button" onclick="recommend.toPost(&quot;project&quot;)"><div class="recommend-categoryItem-bg" style="background: linear-gradient(to right, #18e7ae, #1eebeb)"></div><span class="recommend-categoryItem-text">个人项目</span><i class="fa-solid fa-code"></i></a></div></div></div><div class="recommend-wrapper" id="recommend-post"><div class="recommend-post-main" id="recommend-post-main"><div class="recommend-post-cover" onclick="recommend.toPost(&quot;about&quot;)" style="background: var(--recommend-main) url(https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Light_up_Sky.gif) no-repeat center/cover"></div><div class="recommend-post-cover-wrapper"><div class="recommend-post-cover-info" onclick="recommend.toPost(&quot;about&quot;)"><div class="recommend-post-cover-subTitle">缥缃筆記</div><div class="recommend-post-cover-title">芸编偶拾 • 闲敲平仄煮时光</div></div><div class="recommend-post-cover-more" onclick="window.event.cancelBubble=true;recommend.hideCover();"><div class="recommend-post-cover-more-bg"></div><i class="fa-solid fa-circle-plus"></i><span>更多推荐</span></div></div></div><div class="recommend-post-list" onmouseleave="window.event.cancelBubble=true;recommend.showCover();"><div class="recommend-post-item"><div class="recommend-post-item-cover" onclick="recommend.toPost(&quot;posts/f8e37cbd.html&quot;)"><img src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Oyama_Mahiro.jpg" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" title="生成函数笔记"/></div><div class="recommend-post-item-title" onclick="recommend.toPost(&quot;posts/f8e37cbd.html&quot;)" title="生成函数笔记">生成函数笔记</div></div><div class="recommend-post-item"><div class="recommend-post-item-cover" onclick="recommend.toPost(&quot;posts/75364206.html&quot;)"><img src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Yanami_Anna.png" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" title="牛客小白月赛117题解"/></div><div class="recommend-post-item-title" onclick="recommend.toPost(&quot;posts/75364206.html&quot;)" title="牛客小白月赛117题解">牛客小白月赛117题解</div></div><div class="recommend-post-item"><div class="recommend-post-item-cover" onclick="recommend.toPost(&quot;posts/fec4b5ee.html&quot;)"><img src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Konachan.com%20-%20368742%20sample.jpg" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" title="牛客2025秋季算法编程训练联赛5-基础组题解"/></div><div class="recommend-post-item-title" onclick="recommend.toPost(&quot;posts/fec4b5ee.html&quot;)" title="牛客2025秋季算法编程训练联赛5-基础组题解">牛客2025秋季算法编程训练联赛5-基础组题解</div></div><div class="recommend-post-item"><div class="recommend-post-item-cover" onclick="recommend.toPost(&quot;posts/704d10ab.html&quot;)"><img src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/2025-03-12%20122109.png" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" title="火箭轨迹三维模拟（低空）"/></div><div class="recommend-post-item-title" onclick="recommend.toPost(&quot;posts/704d10ab.html&quot;)" title="火箭轨迹三维模拟（低空）">火箭轨迹三维模拟（低空）</div></div><div class="recommend-post-item"><div class="recommend-post-item-cover" onclick="recommend.toPost(&quot;posts/6cc39754.html&quot;)"><img src="https://image-host-for-meta.oss-cn-hangzhou.aliyuncs.com/blog-img/Tifa1.jpg" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" title="洛谷题解--记3月24日训练"/></div><div class="recommend-post-item-title" onclick="recommend.toPost(&quot;posts/6cc39754.html&quot;)" title="洛谷题解--记3月24日训练">洛谷题解--记3月24日训练</div></div><div class="recommend-post-item"><div class="recommend-post-item-cover" onclick="recommend.toPost(&quot;posts/ee1dab94.html&quot;)"><img src="" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" title="概率论与数理统计期末复习"/></div><div class="recommend-post-item-title" onclick="recommend.toPost(&quot;posts/ee1dab94.html&quot;)" title="概率论与数理统计期末复习">概率论与数理统计期末复习</div></div></div></div></div></div>';
              parent_div_git.insertAdjacentHTML("afterbegin",item_html);
            },
            toRandomPost: function() {
              var posts_path = "posts/4a52651e.html,posts/f2a626f9.html,posts/73c6c6c9.html,posts/18120.html,posts/56011.html,posts/54962.html,posts/4b32681.html,posts/1baa34af.html,posts/3538e23e.html,posts/45c6e9dc.html,posts/6ecdd18f.html,posts/bb2feb5d.html,posts/16107.html,posts/d629c6d1.html,posts/7c1672ff.html,posts/96145f6d.html,posts/c43560d9.html,posts/e91093f0.html,posts/c72ae656.html,posts/5a9acf5a.html,posts/5e8d613b.html,posts/bfbde536.html,posts/623e9466.html,posts/928debf2.html,posts/49f4a0d6.html,posts/dec5d03c.html,posts/b05b7d2d.html,posts/257e1115.html,posts/39efaf90.html,posts/8f5e0b51.html,posts/b9a16b3b.html,posts/3de51743.html,posts/ee1dab94.html,posts/6cc39754.html,posts/704d10ab.html,posts/fec4b5ee.html,posts/75364206.html,posts/f8e37cbd.html".split(',');
              var randomPost = posts_path[Math.floor(Math.random() * posts_path.length)];
              window.recommend.toPost(randomPost);
            },
            toPost: function(href) {
              if (typeof pjax !== 'undefined') pjax.loadUrl('/' + href);
              else window.location.href = window.location.origin + (href.charAt(0) === '/' ? '' : '/') + href;
            },
            hideCover: function() {
              const $main = document.querySelector("#recommend-post-main");
              $main.className = 'recommend-post-main recommend-hide';
            },
            showCover: function() {
              const $main = document.querySelector("#recommend-post-main");
              if ($main) $main.className = 'recommend-post-main';
            },
            postScroll: function(dom) {
              const e = window.event || arguments.callee.caller.arguments[0];
              if (document.body.clientWidth <= 1200) {
                let o = -e.wheelDelta / 2;
                dom.scrollLeft += o;
                e.preventDefault();
              }
            }
          }
          console.log(
            "%c plugin ⭐ hexo_butterfly_recommend ⭐ https://github.com/weizwz/hexo-butterfly-recommend ",
            "color: #fff; padding:3px; font-size:12px; background: linear-gradient(90deg, #358bff, #1eebeb);"
          )
        }
        window.recommend.hexo_butterfly_recommend_init();
      </script><!-- hexo injector body_end end --></body></html>